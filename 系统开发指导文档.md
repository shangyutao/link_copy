# 视频下载后台系统开发指导文档

## 📝 文档说明
本文档专为AI开发人员提供系统实现指导，详细说明了视频下载后台系统的架构、功能和实现要求。

## 🎯 系统概述

### 核心功能
这是一个基于 Node.js 的视频下载后台服务系统，主要功能：
1. **接收视频链接** → **自动识别平台** → **下载视频** → **返回文件**
2. **任务状态管理** → **进度追踪** → **文件清理** → **存储管理**

### 业务流程
前端输入链接 → 后端创建任务 → 返回任务ID → 前端轮询状态 → 下载完成 → 获取视频文件

## 🏗️ 系统架构

### 技术栈要求
- **运行环境**: Node.js (>=16.x)
- **框架**: Express.js 或 Fastify
- **数据库**: MongoDB 或 MySQL
- **缓存**: Redis (用于任务队列和缓存)
- **文件存储**: 本地文件系统或云存储
- **任务队列**: Bull 或 Agenda

### 目录结构
```
video-downloader/
├── src/
│   ├── controllers/     # 控制器层
│   ├── services/        # 业务逻辑层
│   ├── models/          # 数据模型
│   ├── utils/           # 工具函数
│   ├── downloaders/     # 各平台下载器
│   ├── middleware/      # 中间件
│   └── routes/          # 路由定义
├── tests/               # 测试文件
├── storage/             # 文件存储目录
└── config/              # 配置文件
```

## 🔧 核心接口实现指导

### 1. 提交下载任务接口 (`POST /api/video/download`)

**实现逻辑**:
```javascript
async function createDownloadTask(req, res) {
  const { url, platform } = req.body;
  
  // 1. 参数验证
  if (!url || !isValidUrl(url)) {
    return res.status(400).json({ code: 400, message: '无效的URL' });
  }
  
  // 2. 平台识别 (如果未指定platform)
  const detectedPlatform = platform || await detectPlatform(url);
  if (!detectedPlatform) {
    return res.status(400).json({ code: 1001, message: '不支持的视频平台' });
  }
  
  // 3. 检查是否已存在相同任务
  const existingTask = await findTaskByUrl(url);
  if (existingTask) {
    return res.status(409).json({ code: 409, message: '任务已存在', data: existingTask });
  }
  
  // 4. 创建任务记录
  const taskId = generateUniqueId();
  const task = await createTask({
    taskId,
    originalUrl: url,
    platform: detectedPlatform,
    status: 'pending',
    createTime: new Date()
  });
  
  // 5. 添加到下载队列
  await addToDownloadQueue(taskId);
  
  // 6. 返回任务信息
  res.json({
    code: 200,
    message: '任务创建成功',
    data: {
      taskId,
      status: 'pending',
      platform: detectedPlatform,
      createTime: task.createTime
    }
  });
}
```

**关键实现点**:
- URL验证使用正则表达式或URL解析库
- 平台识别通过域名匹配或URL模式识别
- 任务ID使用UUID或自定义生成算法
- 使用事务确保数据一致性

### 2. 查询任务状态接口 (`GET /api/video/status/{taskId}`)

**实现逻辑**:
```javascript
async function getTaskStatus(req, res) {
  const { taskId } = req.params;
  
  // 1. 查询任务信息
  const task = await findTaskById(taskId);
  if (!task) {
    return res.status(404).json({ code: 404, message: '任务不存在' });
  }
  
  // 2. 构造响应数据
  const responseData = {
    taskId: task.taskId,
    status: task.status,
    progress: task.progress || 0,
    videoInfo: task.videoInfo || null
  };
  
  // 3. 根据状态添加额外信息
  if (task.status === 'completed') {
    responseData.downloadUrl = `/api/video/file/${taskId}`;
  } else if (task.status === 'failed') {
    responseData.errorMessage = task.errorMessage;
  }
  
  res.json({
    code: 200,
    message: '查询成功',
    data: responseData
  });
}
```

**关键实现点**:
- 任务不存在时返回404状态码
- 根据不同状态返回不同字段
- 进度信息实时更新

### 3. 获取视频文件接口 (`GET /api/video/file/{taskId}`)

**实现逻辑**:
```javascript
async function getVideoFile(req, res) {
  const { taskId } = req.params;
  
  // 1. 验证任务存在且已完成
  const task = await findTaskById(taskId);
  if (!task || task.status !== 'completed') {
    return res.status(404).json({ code: 1004, message: '视频文件不存在' });
  }
  
  // 2. 检查文件是否存在
  const filePath = task.filePath;
  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ code: 1004, message: '视频文件不存在' });
  }
  
  // 3. 设置响应头
  const stat = fs.statSync(filePath);
  const fileSize = stat.size;
  const fileName = path.basename(filePath);
  
  res.setHeader('Content-Type', 'video/mp4');
  res.setHeader('Content-Length', fileSize);
  res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
  
  // 4. 支持断点续传
  const range = req.headers.range;
  if (range) {
    // 实现Range请求处理
    handleRangeRequest(res, filePath, range, fileSize);
  } else {
    // 直接返回文件流
    const stream = fs.createReadStream(filePath);
    stream.pipe(res);
  }
}
```

**关键实现点**:
- 文件存在性检查
- 支持HTTP Range请求（断点续传）
- 正确设置Content-Type和Content-Disposition
- 使用流式传输避免内存占用

### 4. 视频下载核心逻辑

**平台识别器实现**:
```javascript
class PlatformDetector {
  static platforms = {
    'douyin': {
      patterns: ['douyin.com', 'dy.com'],
      downloader: DouyinDownloader
    },
    'bilibili': {
      patterns: ['bilibili.com', 'b23.tv'],
      downloader: BilibiliDownloader
    }
    // 更多平台...
  };
  
  static async detect(url) {
    // 处理短链接展开
    const expandedUrl = await this.expandShortUrl(url);
    
    // 匹配平台
    for (const [platform, config] of Object.entries(this.platforms)) {
      if (config.patterns.some(pattern => expandedUrl.includes(pattern))) {
        return platform;
      }
    }
    return null;
  }
}
```

**下载器基类**:
```javascript
class BaseDownloader {
  constructor(taskId, url) {
    this.taskId = taskId;
    this.url = url;
  }
  
  async download() {
    try {
      // 1. 更新状态为下载中
      await this.updateTaskStatus('downloading');
      
      // 2. 获取视频信息
      const videoInfo = await this.getVideoInfo();
      await this.updateTaskVideoInfo(videoInfo);
      
      // 3. 下载视频
      const filePath = await this.downloadVideo();
      
      // 4. 更新完成状态
      await this.updateTaskStatus('completed', { filePath });
      
    } catch (error) {
      // 5. 错误处理
      await this.updateTaskStatus('failed', { errorMessage: error.message });
    }
  }
  
  // 子类需要实现的方法
  async getVideoInfo() { throw new Error('Need implementation'); }
  async downloadVideo() { throw new Error('Need implementation'); }
}
```

**具体平台下载器示例**:
```javascript
class DouyinDownloader extends BaseDownloader {
  async getVideoInfo() {
    // 1. 解析抖音链接获取视频ID
    const videoId = this.extractVideoId(this.url);
    
    // 2. 调用抖音API获取视频信息
    const apiUrl = `https://api.douyin.com/aweme/v1/aweme/detail/?aweme_id=${videoId}`;
    const response = await axios.get(apiUrl, { headers: this.getHeaders() });
    
    // 3. 解析响应数据
    return {
      title: response.data.aweme_detail.desc,
      duration: response.data.aweme_detail.duration,
      downloadUrl: response.data.aweme_detail.video.play_addr.url_list[0]
    };
  }
  
  async downloadVideo() {
    const videoInfo = await this.getVideoInfo();
    const fileName = `${this.taskId}.mp4`;
    const filePath = path.join(config.storagePath, fileName);
    
    // 使用流式下载并显示进度
    const response = await axios({
      method: 'GET',
      url: videoInfo.downloadUrl,
      responseType: 'stream',
      headers: this.getHeaders()
    });
    
    const writer = fs.createWriteStream(filePath);
    const totalSize = parseInt(response.headers['content-length']);
    let downloadedSize = 0;
    
    response.data.on('data', (chunk) => {
      downloadedSize += chunk.length;
      const progress = Math.round((downloadedSize / totalSize) * 100);
      this.updateProgress(progress);
    });
    
    response.data.pipe(writer);
    
    return new Promise((resolve, reject) => {
      writer.on('finish', () => resolve(filePath));
      writer.on('error', reject);
    });
  }
}
```

### 5. 清理功能实现

**立即清理**:
```javascript
async function cleanVideoImmediately(req, res) {
  const { taskId } = req.params;
  
  // 1. 查询任务
  const task = await findTaskById(taskId);
  if (!task) {
    return res.status(404).json({ code: 404, message: '任务不存在' });
  }
  
  // 2. 删除文件
  if (task.filePath && fs.existsSync(task.filePath)) {
    fs.unlinkSync(task.filePath);
  }
  
  // 3. 删除数据库记录
  await deleteTask(taskId);
  
  // 4. 取消相关的定时清理任务
  await cancelScheduledClean(taskId);
  
  res.json({
    code: 200,
    message: '清理成功',
    data: { taskId, cleanTime: new Date() }
  });
}
```

**定时清理**:
```javascript
async function scheduleClean(req, res) {
  const { taskId, delayHours } = req.body;
  
  // 1. 创建清理任务记录
  const cleanJob = await createCleanJob({
    jobId: generateUniqueId(),
    taskId,
    scheduleTime: new Date(Date.now() + delayHours * 60 * 60 * 1000),
    status: 'pending'
  });
  
  // 2. 添加到任务队列
  await scheduleQueue.add('cleanVideo', { taskId }, {
    delay: delayHours * 60 * 60 * 1000,
    jobId: cleanJob.jobId
  });
  
  res.json({
    code: 200,
    message: '定时清理设置成功',
    data: cleanJob
  });
}
```

## 📊 数据库设计实现

### MongoDB 示例
```javascript
// 任务模型
const taskSchema = new mongoose.Schema({
  taskId: { type: String, unique: true, required: true },
  originalUrl: { type: String, required: true },
  platform: { type: String, required: true },
  status: { 
    type: String, 
    enum: ['pending', 'downloading', 'completed', 'failed'],
    default: 'pending'
  },
  progress: { type: Number, default: 0 },
  videoInfo: {
    title: String,
    duration: Number,
    size: Number,
    thumbnail: String
  },
  filePath: String,
  fileSize: Number,
  errorMessage: String,
  createTime: { type: Date, default: Date.now },
  updateTime: { type: Date, default: Date.now },
  completeTime: Date
});

// 清理任务模型
const cleanJobSchema = new mongoose.Schema({
  jobId: { type: String, unique: true, required: true },
  taskId: { type: String, required: true },
  scheduleTime: { type: Date, required: true },
  status: {
    type: String,
    enum: ['pending', 'executed', 'cancelled'],
    default: 'pending'
  },
  createTime: { type: Date, default: Date.now },
  executeTime: Date
});
```

## 🔄 任务队列实现

```javascript
const Queue = require('bull');
const downloadQueue = new Queue('video download', process.env.REDIS_URL);

// 下载任务处理器
downloadQueue.process(async (job) => {
  const { taskId } = job.data;
  
  try {
    const task = await findTaskById(taskId);
    const DownloaderClass = PlatformDetector.platforms[task.platform].downloader;
    const downloader = new DownloaderClass(taskId, task.originalUrl);
    
    await downloader.download();
  } catch (error) {
    console.error(`下载任务失败: ${taskId}`, error);
    throw error;
  }
});

// 清理任务处理器
const cleanQueue = new Queue('video clean', process.env.REDIS_URL);
cleanQueue.process('cleanVideo', async (job) => {
  const { taskId } = job.data;
  await cleanVideoImmediately({ params: { taskId } }, mockRes);
});
```

## 🛡️ 错误处理和安全

### 全局错误处理
```javascript
app.use((error, req, res, next) => {
  console.error('全局错误:', error);
  
  if (error.code) {
    return res.status(400).json({ code: error.code, message: error.message });
  }
  
  res.status(500).json({ code: 500, message: '服务器内部错误' });
});
```

### 安全措施
- **输入验证**: 严格验证所有输入参数
- **文件路径安全**: 防止路径遍历攻击
- **速率限制**: 限制API调用频率
- **文件大小限制**: 限制下载文件大小
- **病毒扫描**: 可选的文件安全检查

## 🧪 测试指导

### 单元测试示例
```javascript
describe('视频下载服务', () => {
  test('应该正确识别抖音平台', async () => {
    const url = 'https://v.douyin.com/xxxxx';
    const platform = await PlatformDetector.detect(url);
    expect(platform).toBe('douyin');
  });
  
  test('应该创建下载任务', async () => {
    const task = await createDownloadTask('test-url', 'douyin');
    expect(task.taskId).toBeDefined();
    expect(task.status).toBe('pending');
  });
});
```

## 📝 配置文件示例

```javascript
// config/default.js
module.exports = {
  server: {
    port: process.env.PORT || 3000,
    host: '0.0.0.0'
  },
  database: {
    mongodb: process.env.DB_URL || 'mongodb://localhost:27017/video_downloader'
  },
  redis: {
    url: process.env.REDIS_URL || 'redis://localhost:6379'
  },
  storage: {
    path: process.env.STORAGE_PATH || './storage',
    maxFileSize: 1024 * 1024 * 1024, // 1GB
    cleanAfterHours: 24
  },
  download: {
    maxConcurrent: 5,
    timeout: 30000,
    retryTimes: 3
  }
};
```

## 🚀 部署建议

### Docker 部署
```dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

### 环境要求
- **Node.js**: >=16.x
- **内存**: 最小2GB，推荐4GB
- **存储**: 根据视频文件大小规划
- **网络**: 稳定的外网连接

---

## 💡 开发提示

1. **模块化设计**: 每个平台的下载器独立实现
2. **错误恢复**: 实现下载失败重试机制
3. **监控日志**: 详细记录操作日志便于调试
4. **性能优化**: 使用流式处理避免内存溢出
5. **扩展性**: 设计时考虑新平台的接入

这份文档提供了完整的实现指导，AI开发人员可以根据这些详细说明来构建整个系统。