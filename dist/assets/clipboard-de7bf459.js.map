{"version":3,"file":"clipboard-de7bf459.js","sources":["../../src/services/api.js","../../node_modules/@ffmpeg/ffmpeg/dist/esm/const.js","../../node_modules/@ffmpeg/ffmpeg/dist/esm/types.js","../../src/services/video-compress.js","../../src/services/video.js","../../src/utils/storage.js","../../src/stores/task.js","../../src/utils/clipboard.js"],"sourcesContent":["import axios from 'axios'\nimport { showToast, showLoadingToast, closeToast } from 'vant'\n\n// 环境配置\nconst isDevelopment = import.meta.env.DEV\n// 优先使用环境变量，便于在生产环境绕过静态站点代理直连后端\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL || (isDevelopment \n  ? 'http://47.109.155.18:2222/api'  // 开发环境\n  : '/api'  // 默认生产为相对路径（Netlify 代理）\n)\n\nconsole.log('API环境配置:', { isDevelopment, API_BASE_URL })\n\n// 创建axios实例\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n\n// 请求拦截器\napi.interceptors.request.use(\n  config => {\n    // 显示loading\n    if (config.showLoading !== false) {\n      showLoadingToast({\n        message: '请求中...',\n        forbidClick: true,\n        duration: 0\n      })\n    }\n    \n    // 若为文件上传(FormData)，移除默认的 JSON Content-Type，交给浏览器自动设置带 boundary 的 multipart/form-data\n    try {\n      if (config.data instanceof FormData && config.headers) {\n        delete config.headers['Content-Type']\n        delete config.headers['content-type']\n      }\n    } catch {}\n    \n    console.log('API请求:', config.method?.toUpperCase(), config.url, config.data)\n    return config\n  },\n  error => {\n    closeToast()\n    console.error('请求错误:', error)\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\napi.interceptors.response.use(\n  response => {\n    closeToast()\n    \n    const { data } = response\n    console.log('API响应:', response.config.url, data)\n    \n    // 根据业务状态码处理\n    if (data.code && data.code !== 200) {\n      const errorMessage = data.message || '请求失败'\n      showToast({\n        type: 'fail',\n        message: errorMessage\n      })\n      return Promise.reject(new Error(errorMessage))\n    }\n    \n    return data\n  },\n  error => {\n    closeToast()\n    \n    console.error('响应错误:', error)\n    \n    let errorMessage = '网络错误，请稍后重试'\n    \n    if (error.response) {\n      const { status, data } = error.response\n      \n      switch (status) {\n        case 400:\n          errorMessage = data.message || '请求参数错误'\n          break\n        case 401:\n          errorMessage = '未授权，请重新登录'\n          break\n        case 403:\n          errorMessage = '没有权限访问'\n          break\n        case 404:\n          errorMessage = '请求的资源不存在'\n          break\n        case 408:\n          errorMessage = '请求超时'\n          break\n        case 500:\n          errorMessage = '服务器内部错误'\n          break\n        case 503:\n          errorMessage = '服务暂时不可用'\n          break\n        default:\n          if (data && data.message) {\n            errorMessage = data.message\n          }\n      }\n    } else if (error.code === 'ECONNABORTED') {\n      errorMessage = '请求超时，请检查网络连接'\n    } else if (error.message === 'Network Error') {\n      errorMessage = '网络连接异常'\n    }\n    \n    showToast({\n      type: 'fail',\n      message: errorMessage\n    })\n    \n    return Promise.reject(error)\n  }\n)\n\nexport default api\nexport { API_BASE_URL } ","export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.9\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n","export var FFFSType;\n(function (FFFSType) {\n    FFFSType[\"MEMFS\"] = \"MEMFS\";\n    FFFSType[\"NODEFS\"] = \"NODEFS\";\n    FFFSType[\"NODERAWFS\"] = \"NODERAWFS\";\n    FFFSType[\"IDBFS\"] = \"IDBFS\";\n    FFFSType[\"WORKERFS\"] = \"WORKERFS\";\n    FFFSType[\"PROXYFS\"] = \"PROXYFS\";\n})(FFFSType || (FFFSType = {}));\n","import { FFmpeg } from '@ffmpeg/ffmpeg'\nimport { fetchFile } from '@ffmpeg/util'\n\nlet ffmpegInstance = null\nlet ffmpegLoadingPromise = null\n\nasync function getFFmpeg() {\n  if (ffmpegInstance) {\n    console.log('✅ 使用已加载的 FFmpeg 实例')\n    return ffmpegInstance\n  }\n  \n  if (ffmpegLoadingPromise) {\n    console.log('⏳ FFmpeg 正在加载中，等待...')\n    return ffmpegLoadingPromise\n  }\n  \n  console.log('🚀 开始加载 FFmpeg...')\n  ffmpegLoadingPromise = new Promise(async (resolve, reject) => {\n    // 添加超时机制\n    const timeout = setTimeout(() => {\n      console.error('❌ FFmpeg 加载超时 (30秒)')\n      ffmpegLoadingPromise = null\n      reject(new Error('FFmpeg 加载超时'))\n    }, 30000)\n    \n    try {\n      const ffmpeg = new FFmpeg()\n      console.log('📦 FFmpeg 实例创建成功')\n      \n      // 添加事件监听器\n      ffmpeg.on('log', ({ message }) => {\n        console.log('FFmpeg log:', message)\n      })\n      \n      ffmpeg.on('progress', ({ progress, time }) => {\n        console.log(`FFmpeg progress: ${Math.round(progress * 100)}% (time: ${time}s)`)\n      })\n      \n      console.log('🔄 开始加载 FFmpeg 核心文件...')\n      console.log('📥 尝试下载核心文件...')\n      \n      // 先测试网络连接\n      try {\n        const testResponse = await fetch('https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js', { \n          method: 'HEAD',\n          mode: 'cors'\n        })\n        console.log('✅ 网络连接测试成功:', testResponse.status)\n      } catch (networkError) {\n        console.warn('⚠️ 网络连接测试失败:', networkError)\n      }\n      \n      await ffmpeg.load({\n        coreURL: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js',\n        wasmURL: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm',\n        workerURL: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.worker.js'\n      })\n      console.log('✅ FFmpeg 核心文件加载完成')\n      \n      clearTimeout(timeout)\n      ffmpegInstance = ffmpeg\n      console.log('🎉 FFmpeg 完全加载成功')\n      resolve(ffmpeg)\n    } catch (error) {\n      clearTimeout(timeout)\n      console.error('❌ FFmpeg 加载失败:', error)\n      console.error('错误详情:', {\n        name: error.name,\n        message: error.message,\n        stack: error.stack\n      })\n      ffmpegInstance = null\n      reject(error)\n    } finally {\n      ffmpegLoadingPromise = null\n    }\n  })\n  \n  return ffmpegLoadingPromise\n}\n\n/**\n * 将视频转为仅音频的 MP4（AAC），大幅减小体积\n * - 音频参数：单声道、48kHz、64kbps\n * - 失败时抛出错误，调用方可回退原文件\n * @param {File} inputFile 视频文件\n * @returns {Promise<Object>} 压缩结果 {file, compressed}\n */\nexport async function transcodeToAudioOnlyMp4(inputFile) {\n  console.log('🎬 开始压缩视频:', {\n    name: inputFile.name,\n    size: inputFile.size,\n    type: inputFile.type\n  })\n  \n  try {\n    const ffmpeg = await getFFmpeg()\n    console.log('✅ FFmpeg 加载成功')\n\n    const inputName = 'input.mp4'\n    const outputName = 'output_audio.mp4'\n\n    console.log('📝 写入输入文件...')\n    await ffmpeg.writeFile(inputName, await fetchFile(inputFile))\n    console.log('✅ 输入文件写入完成')\n\n    console.log('🔄 开始转码...')\n    await ffmpeg.exec([\n      '-i', inputName,\n      '-vn',\n      '-ac', '1',\n      '-ar', '48000',\n      '-b:a', '64k',\n      '-c:a', 'aac',\n      '-movflags', '+faststart',\n      outputName\n    ])\n    console.log('✅ 转码完成')\n\n    console.log('📖 读取输出文件...')\n    const data = await ffmpeg.readFile(outputName)\n    console.log('✅ 输出文件读取完成，大小:', data.buffer.byteLength)\n\n    const blob = new Blob([data.buffer], { type: 'video/mp4' })\n    const file = new File([blob], inputFile.name.replace(/\\.[^.]+$/, '') + '_audio.mp4', { type: 'video/mp4' })\n    \n    console.log('🎉 压缩完成:', {\n      originalSize: inputFile.size,\n      newSize: file.size,\n      reduction: Math.round((1 - file.size / inputFile.size) * 100) + '%'\n    })\n\n    // 清理\n    try { await ffmpeg.deleteFile(inputName) } catch (e) { console.warn('清理输入文件失败:', e) }\n    try { await ffmpeg.deleteFile(outputName) } catch (e) { console.warn('清理输出文件失败:', e) }\n\n    return { file, compressed: true }\n  } catch (error) {\n    console.error('❌ 压缩失败:', error)\n    throw error\n  }\n}\n\n/**\n * 若原文件超过阈值，则尝试仅音频转码；否则直接返回原文件。\n * @param {File} inputFile\n * @param {number} thresholdBytes 默认 20MB\n * @returns {Promise<{file: File, compressed: boolean}>}\n */\nexport async function maybeCompressForNetlify(inputFile, thresholdBytes = 20 * 1024 * 1024) {\n  if (!inputFile) throw new Error('无效文件')\n  \n  // 临时完全禁用压缩功能\n  console.log('⚠️ 压缩功能暂时禁用，直接使用原文件')\n  console.log('📝 原因：FFmpeg 核心文件加载失败')\n  console.log('💡 建议：文件大小超过阈值时，请手动压缩后再上传')\n  console.log('📊 文件信息:', {\n    name: inputFile.name,\n    size: (inputFile.size / (1024 * 1024)).toFixed(2) + 'MB',\n    threshold: (thresholdBytes / (1024 * 1024)).toFixed(2) + 'MB'\n  })\n  \n  return { file: inputFile, compressed: false }\n}\n\n\n","import api from './api'\nimport { maybeCompressForNetlify } from './video-compress'\n\n/**\n * 视频相关API服务\n */\nexport const videoApi = {\n  /**\n   * 创建下载任务\n   * @param {string} url - 视频链接\n   * @param {string} platform - 平台名称（可选）\n   * @returns {Promise<Object>} 任务信息\n   */\n  async createDownloadTask(url, platform = null) {\n    const response = await api.post('/video/download', {\n      url,\n      platform\n    })\n    return response.data\n  },\n\n  /**\n   * 上传视频文件\n   * @param {File} file - 视频文件\n   * @param {Function} onProgress - 上传进度回调\n   * @returns {Promise<Object>} 任务信息\n   */\n  async uploadVideoFile(file, onProgress = null) {\n    // 参数验证\n    if (!file || !(file instanceof File)) {\n      throw new Error('请选择有效的视频文件')\n    }\n\n    // 文件大小验证（500MB限制）\n    const MAX_SIZE = 500 * 1024 * 1024 // 500MB\n    if (file.size > MAX_SIZE) {\n      throw new Error(`文件大小不能超过500MB，当前文件大小：${this.formatFileSize(file.size)}`)\n    }\n\n    // 文件类型验证\n    const supportedTypes = [\n      'video/mp4', 'video/avi', 'video/quicktime', 'video/x-msvideo',\n      'video/x-flv', 'video/webm', 'video/x-matroska', 'video/mp4v-es',\n      'video/3gpp', 'video/ogg'\n    ]\n    \n    const supportedExtensions = [\n      '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv', '.m4v', '.3gp', '.ogv'\n    ]\n    \n    const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'))\n    \n    if (!supportedTypes.includes(file.type) && !supportedExtensions.includes(fileExtension)) {\n      throw new Error('不支持的视频格式，请上传 MP4、AVI、MOV、WMV、FLV、WEBM、MKV、M4V、3GP、OGV 格式的视频文件')\n    }\n\n    // 若文件过大，在生产环境尝试压缩为仅音频 MP4，降低体积\n    let uploadFile = file\n    let usedCompressed = false\n    // 默认启用压缩（本地与生产一致），如需禁用可设置 VITE_ENABLE_UPLOAD_COMPRESSION=false\n    const enableCompression = (import.meta.env.VITE_ENABLE_UPLOAD_COMPRESSION !== 'false')\n    const thresholdMb = Number(import.meta.env.VITE_UPLOAD_COMPRESSION_THRESHOLD_MB || 20)\n    const thresholdBytes = Math.max(1, thresholdMb) * 1024 * 1024\n\n    // 先上传原视频，后台进行压缩（避免阻塞用户操作）\n    if (enableCompression && file.size > thresholdBytes) {\n      console.log('🔧 触发压缩逻辑:', {\n        fileSize: file.size,\n        thresholdBytes,\n        enableCompression,\n        isDev: import.meta.env.DEV\n      })\n      try {\n        // 后台压缩，不阻塞当前上传\n        maybeCompressForNetlify(file, thresholdBytes).then(({ file: compacted, compressed }) => {\n          if (compressed) {\n            console.log('✅ 后台压缩完成，下次上传将使用压缩版本:', {\n              originalSize: file.size,\n              newSize: compacted.size,\n              reduction: Math.round((1 - compacted.size / file.size) * 100) + '%'\n            })\n            // 可以存储到 localStorage 供下次使用\n            try {\n              const compressedKey = `compressed_${file.name}_${file.size}`\n              localStorage.setItem(compressedKey, JSON.stringify({\n                name: compacted.name,\n                size: compacted.size,\n                timestamp: Date.now()\n              }))\n            } catch (e) {\n              console.warn('存储压缩信息失败:', e)\n            }\n          } else {\n            console.log('⚠️ 压缩未生效，文件大小未超过阈值或压缩失败')\n          }\n        }).catch(e => {\n          console.warn('❌ 后台压缩失败:', e)\n        })\n      } catch (e) {\n        console.warn('❌ 启动后台压缩失败:', e)\n      }\n    } else {\n      console.log('ℹ️ 跳过压缩:', {\n        enableCompression,\n        fileSize: file.size,\n        thresholdBytes,\n        reason: !enableCompression ? '压缩已禁用' : '文件未超过阈值'\n      })\n    }\n\n    // 使用原文件上传\n    uploadFile = file\n\n    // 创建FormData\n    const formData = new FormData()\n    formData.append('video', uploadFile)\n\n    // 配置请求选项\n    const config = {\n      // 不手动设置 Content-Type，交给浏览器自动生成带 boundary 的 multipart/form-data\n      timeout: 300000, // 5分钟超时\n      onUploadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)\n          onProgress(progress)\n        }\n      }\n    }\n\n    // 若当前使用了仅音频压缩，添加一个提示性请求头（不影响multipart自动设置）\n    if (usedCompressed) {\n      config.headers = {\n        ...(config.headers || {}),\n        'X-Upload-Audio-Only': '1'\n      }\n    }\n\n    try {\n      const response = await api.post('/video/upload', formData, config)\n      return response.data\n    } catch (error) {\n      // 如果使用了压缩文件且后端返回格式相关错误，自动回退上传原文件\n      const status = error?.response?.status\n      const bodyMsg = error?.response?.data?.message || ''\n      const isFormatError = [400, 415, 422].includes(status) || /format|mime|audio|codec/i.test(bodyMsg)\n      if (usedCompressed && isFormatError) {\n        try {\n          const fallbackForm = new FormData()\n          fallbackForm.append('video', file)\n          const resp = await api.post('/video/upload', fallbackForm, config)\n          return resp.data\n        } catch (e) {\n          throw e\n        }\n      }\n      if (error.code === 'ECONNABORTED') {\n        throw new Error('上传超时，请检查网络连接或尝试上传更小的文件')\n      }\n      if (error.response?.status === 413) {\n        throw new Error('文件过大，请上传小于500MB的视频文件')\n      }\n      throw error\n    }\n  },\n\n  /**\n   * 查询任务状态\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 任务状态信息\n   */\n  async getTaskStatus(taskId) {\n    const response = await api.get(`/video/status/${taskId}`, {\n      showLoading: false // 轮询时不显示loading\n    })\n    return response.data\n  },\n\n  /**\n   * 获取视频文件下载链接\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<string>} 下载链接\n   */\n  async getDownloadUrl(taskId) {\n    // 返回直接下载链接\n    return `${api.defaults.baseURL}/video/file/${taskId}`\n  },\n\n  /**\n   * 清理视频文件（立即删除）\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 删除结果\n   */\n  async cleanVideo(taskId) {\n    const response = await api.delete(`/video/clean/${taskId}`, {\n      showLoading: false // 避免显示loading，因为清理操作通常在后台进行\n    })\n    return response.data\n  },\n\n  /**\n   * 删除视频文件 (向后兼容)\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 删除结果\n   */\n  async deleteTask(taskId) {\n    return this.cleanVideo(taskId)\n  },\n\n  /**\n   * 获取支持的平台列表\n   * @returns {Promise<Object>} 平台列表\n   */\n  async getSupportedPlatforms() {\n    const response = await api.get('/video/platforms')\n    return response.data\n  },\n\n  /**\n   * 获取任务列表\n   * @param {Object} params - 查询参数\n   * @returns {Promise<Object>} 任务列表\n   */\n  async getTaskList(params = {}) {\n    const response = await api.get('/video/tasks', { params })\n    return response.data\n  },\n\n  /**\n   * 获取系统统计信息\n   * @returns {Promise<Object>} 统计信息\n   */\n  async getStats() {\n    const response = await api.get('/video/stats')\n    return response.data\n  },\n\n  /**\n   * 批量清理过期文件\n   * @param {number} hours - 过期小时数\n   * @returns {Promise<Object>} 清理结果\n   */\n  async cleanExpiredFiles(hours = 24) {\n    const response = await api.post('/video/clean/expired', {\n      hours\n    })\n    return response.data\n  },\n\n  /**\n   * 重试失败任务\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 重试结果\n   */\n  async retryTask(taskId) {\n    const response = await api.post(`/video/retry/${taskId}`)\n    return response.data\n  },\n\n  /**\n   * 获取视频预览信息\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 预览信息\n   */\n  async getVideoPreview(taskId) {\n    const response = await api.get(`/video/preview/${taskId}`)\n    return response\n  },\n\n  /**\n   * 视频音频转文案\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 转文案结果\n   */\n  async transcribeVideo(taskId) {\n    const response = await api.post(`/video/transcribe/${taskId}`)\n    return response.data\n  },\n\n  /**\n   * AI优化文案\n   * @param {string} text - 原始文案\n   * @param {Object} options - 优化选项\n   * @returns {Promise<Object>} 优化结果\n   */\n  async optimizeText(text, options = {}) {\n    // 参数验证\n    if (!text || typeof text !== 'string') {\n      throw new Error('文案内容不能为空')\n    }\n    \n    const trimmedText = text.trim()\n    if (trimmedText.length === 0) {\n      throw new Error('文案内容不能为空')\n    }\n    \n    // 检查字符长度限制\n    const MAX_LENGTH = 10000\n    if (trimmedText.length > MAX_LENGTH) {\n      throw new Error(`文案长度不能超过${MAX_LENGTH}字符，当前长度：${trimmedText.length}`)\n    }\n    \n    // 设置超时时间（接口文档要求至少120秒）\n    const timeout = options.timeout || 120000 // 120秒\n    \n    // 如果文案较长，需要分段处理\n    const CHUNK_SIZE = 1500\n    if (trimmedText.length > CHUNK_SIZE) {\n      return await this._optimizeTextInChunks(trimmedText, timeout)\n    }\n    \n    // 单段处理\n    try {\n      const response = await api.post('/video/optimize-text', {\n        text: trimmedText\n      }, {\n        timeout,\n        showLoading: options.showLoading !== false\n      })\n      return response.data\n    } catch (error) {\n      if (error.code === 'ECONNABORTED' || error.response?.status === 408) {\n        throw new Error('AI优化请求超时，建议将长文案分段提交')\n      }\n      throw error\n    }\n  },\n\n  /**\n   * 分段优化文案（私有方法）\n   * @param {string} text - 原始文案\n   * @param {number} timeout - 超时时间\n   * @returns {Promise<Object>} 优化结果\n   */\n  async _optimizeTextInChunks(text, timeout) {\n    const CHUNK_SIZE = 1500\n    const chunks = []\n    \n    // 按句号、问号、感叹号等自然断句分段\n    const sentences = text.split(/([。！？\\.\\!\\?]+)/)\n    let currentChunk = ''\n    \n    for (let i = 0; i < sentences.length; i++) {\n      const sentence = sentences[i]\n      \n      if (currentChunk.length + sentence.length <= CHUNK_SIZE) {\n        currentChunk += sentence\n      } else {\n        if (currentChunk.trim()) {\n          chunks.push(currentChunk.trim())\n        }\n        currentChunk = sentence\n      }\n    }\n    \n    // 添加最后一段\n    if (currentChunk.trim()) {\n      chunks.push(currentChunk.trim())\n    }\n    \n    // 如果没有合适的断句，强制按字符数分段\n    if (chunks.length === 1 && chunks[0].length > CHUNK_SIZE) {\n      chunks.length = 0\n      for (let i = 0; i < text.length; i += CHUNK_SIZE) {\n        chunks.push(text.slice(i, i + CHUNK_SIZE))\n      }\n    }\n    \n    console.log(`文案分为${chunks.length}段进行优化`)\n    \n    // 逐段优化\n    const optimizedChunks = []\n    const errors = []\n    \n    for (let i = 0; i < chunks.length; i++) {\n      try {\n        console.log(`正在优化第${i + 1}/${chunks.length}段...`)\n        const response = await api.post('/video/optimize-text', {\n          text: chunks[i]\n        }, {\n          timeout,\n          showLoading: false // 分段时不显示loading，避免频繁弹窗\n        })\n        \n        optimizedChunks.push(response.data.optimizedText || chunks[i])\n        \n        // 分段之间添加小延迟，避免请求过于频繁\n        if (i < chunks.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000))\n        }\n      } catch (error) {\n        console.error(`第${i + 1}段优化失败:`, error)\n        errors.push(`第${i + 1}段: ${error.message}`)\n        optimizedChunks.push(chunks[i]) // 使用原文\n      }\n    }\n    \n    // 合并结果\n    const optimizedText = optimizedChunks.join('')\n    \n    return {\n      originalText: text,\n      optimizedText,\n      optimizationTime: new Date().toISOString(),\n      model: 'doubao-seed-1-6-250615',\n      chunks: chunks.length,\n      errors: errors.length > 0 ? errors : undefined\n    }\n  },\n\n  /**\n   * 获取转文案结果\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 转文案结果\n   */\n  async getTranscriptionResult(taskId) {\n    const response = await api.get(`/video/transcription/${taskId}`, {\n      showLoading: false // 轮询时不显示loading\n    })\n    return response.data\n  },\n\n  /**\n   * 轮询获取转文案最终结果\n   * @param {string} taskId - 任务ID\n   * @param {Object} options - 配置项\n   * @returns {Promise<Object>} 转文案结果\n   */\n  async pollTranscriptionResult(taskId, { interval = 3000, maxAttempts = 100 } = {}) {\n    let attempts = 0\n    while (attempts < maxAttempts) {\n      try {\n        const res = await this.getTranscriptionResult(taskId)\n        if (res.status === 'completed' || res.transcription?.status === 'completed') {\n          return res\n        }\n        if (res.status === 'failed' || res.transcription?.status === 'failed') {\n          throw new Error(res.errorMessage || res.transcription?.errorMessage || '转文案失败')\n        }\n      } catch (error) {\n        // 404 表示结果尚未生成，继续轮询\n        if (error?.response?.status !== 404) {\n          throw error\n        }\n      }\n      await new Promise(resolve => setTimeout(resolve, interval))\n      attempts++\n    }\n    throw new Error('转文案超时，请稍后重试')\n  }\n}\n\n/**\n * 任务轮询器类\n */\nexport class TaskPoller {\n  constructor(taskId, onUpdate, options = {}) {\n    this.taskId = taskId\n    this.onUpdate = onUpdate\n    this.options = {\n      interval: 3000, // 轮询间隔（毫秒）\n      maxAttempts: 100, // 最大尝试次数\n      onError: null, // 错误回调\n      onComplete: null, // 完成回调\n      onFailed: null, // 失败回调\n      ...options\n    }\n    \n    this.isRunning = false\n    this.attempts = 0\n    this.timer = null\n  }\n\n  /**\n   * 开始轮询\n   */\n  start() {\n    if (this.isRunning) {\n      return\n    }\n    \n    this.isRunning = true\n    this.attempts = 0\n    this.poll()\n  }\n\n  /**\n   * 停止轮询\n   */\n  stop() {\n    this.isRunning = false\n    this.attempts = 0\n    \n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  /**\n   * 执行轮询\n   */\n  async poll() {\n    if (!this.isRunning) {\n      return\n    }\n\n    this.attempts++\n\n    try {\n      const result = await videoApi.getTaskStatus(this.taskId)\n      \n      // 调用更新回调\n      if (this.onUpdate) {\n        this.onUpdate(result)\n      }\n\n      // 检查任务状态\n      if (result.status === 'completed') {\n        this.stop()\n        if (this.options.onComplete) {\n          this.options.onComplete(result)\n        }\n        return\n      }\n\n      if (result.status === 'failed') {\n        this.stop()\n        if (this.options.onFailed) {\n          this.options.onFailed(result)\n        }\n        return\n      }\n\n      // 检查是否超过最大尝试次数\n      if (this.attempts >= this.options.maxAttempts) {\n        this.stop()\n        const error = new Error(`轮询超时：已尝试 ${this.attempts} 次`)\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n        return\n      }\n\n      // 继续轮询\n      this.timer = setTimeout(() => {\n        this.poll()\n      }, this.options.interval)\n\n    } catch (error) {\n      console.error('轮询任务状态失败:', error)\n      \n      // 如果是网络错误，继续尝试\n      if (this.attempts < this.options.maxAttempts) {\n        this.timer = setTimeout(() => {\n          this.poll()\n        }, this.options.interval)\n      } else {\n        this.stop()\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n      }\n    }\n  }\n}\n\n/**\n * 转文案轮询器类\n */\nexport class TranscriptionPoller {\n  constructor(taskId, onUpdate, options = {}) {\n    this.taskId = taskId\n    this.onUpdate = onUpdate\n    this.options = {\n      interval: 2000, // 轮询间隔（毫秒）\n      maxAttempts: 150, // 最大尝试次数（5分钟）\n      onError: null,\n      onComplete: null,\n      onFailed: null,\n      ...options\n    }\n    \n    this.isRunning = false\n    this.attempts = 0\n    this.timer = null\n  }\n\n  /**\n   * 开始轮询\n   */\n  start() {\n    if (this.isRunning) {\n      return\n    }\n    \n    this.isRunning = true\n    this.attempts = 0\n    this.poll()\n  }\n\n  /**\n   * 停止轮询\n   */\n  stop() {\n    this.isRunning = false\n    this.attempts = 0\n    \n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  /**\n   * 执行轮询\n   */\n  async poll() {\n    if (!this.isRunning) {\n      return\n    }\n\n    this.attempts++\n\n    try {\n      const result = await videoApi.getTranscriptionResult(this.taskId)\n      \n      // 调用更新回调\n      if (this.onUpdate) {\n        this.onUpdate(result)\n      }\n\n      // 检查转文案状态\n      if (result.transcription && result.transcription.status === 'completed') {\n        this.stop()\n        if (this.options.onComplete) {\n          this.options.onComplete(result)\n        }\n        return\n      }\n\n      if (result.transcription && result.transcription.status === 'failed') {\n        this.stop()\n        if (this.options.onFailed) {\n          this.options.onFailed(result)\n        }\n        return\n      }\n\n      // 检查是否超过最大尝试次数\n      if (this.attempts >= this.options.maxAttempts) {\n        this.stop()\n        const error = new Error(`转文案轮询超时：已尝试 ${this.attempts} 次`)\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n        return\n      }\n\n      // 继续轮询\n      this.timer = setTimeout(() => {\n        this.poll()\n      }, this.options.interval)\n\n    } catch (error) {\n      console.error('轮询转文案状态失败:', error)\n      \n      // 404错误可能表示转文案还未开始或不存在\n      if (error.response?.status === 404) {\n        // 继续轮询\n        if (this.attempts < this.options.maxAttempts) {\n          this.timer = setTimeout(() => {\n            this.poll()\n          }, this.options.interval)\n        } else {\n          this.stop()\n          if (this.options.onError) {\n            this.options.onError(new Error('转文案任务不存在'))\n          }\n        }\n      } else {\n        // 其他错误，停止轮询\n        this.stop()\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n      }\n    }\n  }\n}\n\n/**\n * 视频服务工具函数\n */\nexport const videoUtils = {\n  /**\n   * 检测视频平台\n   * @param {string} url - 视频链接\n   * @returns {string|null} 平台名称\n   */\n  detectPlatform(url) {\n    if (!url) return null\n    \n    const platformMap = {\n      'douyin.com': 'douyin',\n      'dy.com': 'douyin',\n      'bilibili.com': 'bilibili',\n      'b23.tv': 'bilibili',\n      'youtube.com': 'youtube',\n      'youtu.be': 'youtube',\n      'kuaishou.com': 'kuaishou',\n      'ixigua.com': 'ixigua'\n    }\n    \n    for (const [domain, platform] of Object.entries(platformMap)) {\n      if (url.includes(domain)) {\n        return platform\n      }\n    }\n    \n    return null\n  },\n\n  /**\n   * 验证视频链接\n   * @param {string} url - 视频链接\n   * @returns {boolean} 是否有效\n   */\n  isValidVideoUrl(url) {\n    if (!url || typeof url !== 'string') {\n      return false\n    }\n    \n    // 简单的URL验证\n    try {\n      new URL(url)\n      return this.detectPlatform(url) !== null\n    } catch {\n      return false\n    }\n  },\n\n  /**\n   * 清理视频链接\n   * @param {string} url - 原始链接\n   * @returns {string} 清理后的链接\n   */\n  cleanVideoUrl(url) {\n    if (!url) return ''\n    \n    // 移除多余的空格和换行符\n    url = url.trim().replace(/\\s+/g, ' ')\n    \n    // 提取URL\n    const urlMatch = url.match(/(https?:\\/\\/[^\\s]+)/i)\n    if (urlMatch) {\n      return urlMatch[1]\n    }\n    \n    return url\n  },\n\n  /**\n   * 格式化文件大小\n   * @param {number} bytes - 字节数\n   * @returns {string} 格式化后的大小\n   */\n  formatFileSize(bytes) {\n    if (!bytes) return '0 B'\n    \n    const units = ['B', 'KB', 'MB', 'GB']\n    let size = bytes\n    let unitIndex = 0\n    \n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024\n      unitIndex++\n    }\n    \n    return `${size.toFixed(1)} ${units[unitIndex]}`\n  },\n\n  /**\n   * 获取平台显示名称\n   * @param {string} platform - 平台代码\n   * @returns {string} 显示名称\n   */\n  getPlatformDisplayName(platform) {\n    const nameMap = {\n      'douyin': '抖音',\n      'bilibili': '哔哩哔哩',\n      'youtube': 'YouTube',\n      'kuaishou': '快手',\n      'ixigua': '西瓜视频'\n    }\n    \n    return nameMap[platform] || platform || '未知平台'\n  },\n\n  /**\n   * 获取平台颜色\n   * @param {string} platform - 平台代码\n   * @returns {string} 颜色值\n   */\n  getPlatformColor(platform) {\n    const colorMap = {\n      'douyin': '#ff6b6b',\n      'bilibili': '#fb7299',\n      'youtube': '#ff0000',\n      'kuaishou': '#ff6600',\n      'ixigua': '#20b2aa'\n    }\n    \n    return colorMap[platform] || '#666eea'\n  }\n}\n\n/**\n * 视频清理管理器\n */\nexport class VideoCleaner {\n  constructor() {\n    this.currentTaskId = null\n    this.shouldCleanOnUnload = true\n    this.setupCleanupListeners()\n  }\n\n  /**\n   * 设置当前任务ID\n   * @param {string} taskId - 任务ID\n   */\n  setCurrentTask(taskId) {\n    // 清理之前的任务\n    if (this.currentTaskId && this.currentTaskId !== taskId) {\n      this.cleanTask(this.currentTaskId)\n    }\n    this.currentTaskId = taskId\n  }\n\n  /**\n   * 清理指定任务\n   * @param {string} taskId - 任务ID\n   */\n  async cleanTask(taskId) {\n    if (!taskId) return\n    \n    try {\n      await videoApi.cleanVideo(taskId)\n      console.log(`已清理视频缓存: ${taskId}`)\n    } catch (error) {\n      console.warn(`清理视频缓存失败: ${taskId}`, error)\n    }\n  }\n\n  /**\n   * 清理当前任务\n   */\n  async cleanCurrentTask() {\n    if (this.currentTaskId) {\n      await this.cleanTask(this.currentTaskId)\n      this.currentTaskId = null\n    }\n  }\n\n  /**\n   * 设置页面卸载时是否自动清理\n   * @param {boolean} shouldClean - 是否清理\n   */\n  setShouldCleanOnUnload(shouldClean) {\n    this.shouldCleanOnUnload = shouldClean\n  }\n\n  /**\n   * 设置清理监听器\n   */\n  setupCleanupListeners() {\n    // 页面刷新或关闭时清理\n    window.addEventListener('beforeunload', () => {\n      if (this.shouldCleanOnUnload && this.currentTaskId) {\n        // 使用 navigator.sendBeacon 确保清理请求能够发送\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n\n    // 页面隐藏时清理（移动端兼容）\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden' && this.shouldCleanOnUnload && this.currentTaskId) {\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n\n    // 浏览器导航离开时清理\n    window.addEventListener('pagehide', () => {\n      if (this.shouldCleanOnUnload && this.currentTaskId) {\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n  }\n}\n\n// 创建全局清理器实例\nexport const videoCleaner = new VideoCleaner() ","// 本地存储键名常量\nexport const STORAGE_KEYS = {\n  TASK_HISTORY: 'link_copy_task_history',\n  USER_SETTINGS: 'link_copy_user_settings',\n  RECENT_PLATFORMS: 'link_copy_recent_platforms'\n}\n\n// 安全的本地存储操作\nexport const storage = {\n  // 获取数据\n  get(key, defaultValue = null) {\n    try {\n      const item = localStorage.getItem(key)\n      return item ? JSON.parse(item) : defaultValue\n    } catch (error) {\n      console.error('读取本地存储失败:', error)\n      return defaultValue\n    }\n  },\n\n  // 设置数据\n  set(key, value) {\n    try {\n      localStorage.setItem(key, JSON.stringify(value))\n      return true\n    } catch (error) {\n      console.error('保存到本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 删除数据\n  remove(key) {\n    try {\n      localStorage.removeItem(key)\n      return true\n    } catch (error) {\n      console.error('删除本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 清空所有数据\n  clear() {\n    try {\n      localStorage.clear()\n      return true\n    } catch (error) {\n      console.error('清空本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 获取存储大小\n  getSize() {\n    try {\n      let total = 0\n      for (let key in localStorage) {\n        if (localStorage.hasOwnProperty(key)) {\n          total += localStorage[key].length + key.length\n        }\n      }\n      return total\n    } catch (error) {\n      console.error('计算存储大小失败:', error)\n      return 0\n    }\n  }\n}\n\n// 任务历史相关操作\nexport const taskHistory = {\n  // 获取历史记录\n  getHistory() {\n    return storage.get(STORAGE_KEYS.TASK_HISTORY, [])\n  },\n\n  // 添加到历史记录\n  addTask(task) {\n    const history = this.getHistory()\n    \n    // 检查是否已存在\n    const existingIndex = history.findIndex(item => item.taskId === task.taskId)\n    \n    if (existingIndex >= 0) {\n      // 更新现有记录\n      history[existingIndex] = { ...history[existingIndex], ...task }\n    } else {\n      // 添加新记录到开头\n      history.unshift(task)\n    }\n    \n    // 限制历史记录数量\n    const limitedHistory = history.slice(0, 50)\n    \n    return storage.set(STORAGE_KEYS.TASK_HISTORY, limitedHistory)\n  },\n\n  // 更新任务\n  updateTask(taskId, updateData) {\n    const history = this.getHistory()\n    const index = history.findIndex(item => item.taskId === taskId)\n    \n    if (index >= 0) {\n      history[index] = { ...history[index], ...updateData }\n      return storage.set(STORAGE_KEYS.TASK_HISTORY, history)\n    }\n    \n    return false\n  },\n\n  // 删除任务\n  removeTask(taskId) {\n    const history = this.getHistory()\n    const filteredHistory = history.filter(item => item.taskId !== taskId)\n    \n    return storage.set(STORAGE_KEYS.TASK_HISTORY, filteredHistory)\n  },\n\n  // 清空历史记录\n  clearHistory() {\n    return storage.set(STORAGE_KEYS.TASK_HISTORY, [])\n  }\n}\n\n// 用户设置相关操作\nexport const userSettings = {\n  // 获取设置\n  getSettings() {\n    return storage.get(STORAGE_KEYS.USER_SETTINGS, {\n      autoDownload: false,\n      videoQuality: 'high',\n      saveHistory: true,\n      notifications: true\n    })\n  },\n\n  // 更新设置\n  updateSettings(newSettings) {\n    const currentSettings = this.getSettings()\n    const updatedSettings = { ...currentSettings, ...newSettings }\n    \n    return storage.set(STORAGE_KEYS.USER_SETTINGS, updatedSettings)\n  },\n\n  // 重置设置\n  resetSettings() {\n    return storage.remove(STORAGE_KEYS.USER_SETTINGS)\n  }\n} ","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport { videoApi, videoCleaner } from '@/services/video'\nimport { storage, taskHistory as storageTaskHistory } from '@/utils/storage'\n\nexport const useTaskStore = defineStore('task', () => {\n  // 响应式状态\n  const currentTask = ref(null)\n  const taskHistory = ref([])\n  const isLoading = ref(false)\n  const isDownloading = ref(false) // 下载状态\n  const pollingTimer = ref(null)\n  const transcriptionData = ref(null) // 转文案数据\n\n  // 计算属性\n  const currentProgress = computed(() => {\n    return currentTask.value?.progress || 0\n  })\n\n  const isProcessing = computed(() => {\n    const status = currentTask.value?.status\n    return status === 'pending' || status === 'downloading'\n  })\n\n  const isCompleted = computed(() => {\n    return currentTask.value?.status === 'completed'\n  })\n\n  const isFailed = computed(() => {\n    return currentTask.value?.status === 'failed'\n  })\n\n  // 转文案相关状态\n  const isTranscribing = computed(() => {\n    return transcriptionData.value?.status === 'processing'\n  })\n\n  const isTranscriptionCompleted = computed(() => {\n    return transcriptionData.value?.status === 'completed'\n  })\n\n  const isTranscriptionFailed = computed(() => {\n    return transcriptionData.value?.status === 'failed'\n  })\n\n  // 动作方法\n  \n  /**\n   * 创建下载任务\n   */\n  const createTask = async (url, platform = null) => {\n    isLoading.value = true\n    \n    try {\n      // 先清理之前的任务\n      await cleanupCurrentTask()\n      \n      const response = await videoApi.createDownloadTask(url, platform)\n      \n      // 设置当前任务\n      currentTask.value = {\n        taskId: response.taskId,\n        originalUrl: url,\n        platform: response.platform,\n        status: response.status,\n        progress: 0,\n        createTime: response.createTime,\n        isExisting: response.isExisting\n      }\n      \n      // 设置清理器的当前任务\n      videoCleaner.setCurrentTask(response.taskId)\n      \n      // 保存到本地存储\n      await saveTaskToStorage(currentTask.value)\n      \n      // 添加到历史记录\n      addToHistory(currentTask.value)\n      \n      // 开始轮询状态\n      if (isProcessing.value) {\n        startPolling(response.taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('创建任务失败:', error)\n      throw error\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  /**\n   * 创建文件上传任务\n   */\n  const createUploadTask = async (file, onProgress = null) => {\n    isLoading.value = true\n    \n    try {\n      // 先清理之前的任务\n      await cleanupCurrentTask()\n      \n      const response = await videoApi.uploadVideoFile(file, onProgress)\n      \n      // 设置当前任务\n      currentTask.value = {\n        taskId: response.taskId,\n        originalFile: file,\n        fileName: file.name,\n        fileSize: file.size,\n        platform: 'upload', // 标记为上传类型\n        status: response.status,\n        progress: 0,\n        createTime: response.createTime || new Date().toISOString(),\n        isExisting: response.isExisting || false\n      }\n      \n      // 设置清理器的当前任务\n      videoCleaner.setCurrentTask(response.taskId)\n      \n      // 保存到本地存储（不保存文件对象）\n      const taskForStorage = {\n        ...currentTask.value,\n        originalFile: null // 不保存文件对象到localStorage\n      }\n      await saveTaskToStorage(taskForStorage)\n      \n      // 添加到历史记录\n      addToHistory(taskForStorage)\n      \n      // 开始轮询状态\n      if (isProcessing.value) {\n        startPolling(response.taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('创建上传任务失败:', error)\n      throw error\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  /**\n   * 刷新任务状态\n   */\n  const refreshTaskStatus = async (taskId) => {\n    try {\n      const response = await videoApi.getTaskStatus(taskId)\n      console.log('API返回的任务状态:', response)\n      \n      // API响应结构：{code: 200, message: \"查询成功\", data: {...}}\n      // API拦截器返回response.data，即{code, message, data}\n      // 我们需要的实际任务数据在response.data字段中\n      const taskData = response.data || response\n      \n      console.log('提取的任务数据:', taskData)\n      console.log('任务进度:', taskData.progress)\n      \n      // 更新当前任务状态\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value = {\n          ...currentTask.value,\n          ...taskData,\n          updateTime: new Date().toISOString()\n        }\n        \n        console.log('更新后的任务状态:', currentTask.value)\n        \n        // 保存到本地存储\n        await saveTaskToStorage(currentTask.value)\n        \n        // 更新历史记录\n        updateHistoryItem(currentTask.value)\n      } else if (!currentTask.value) {\n        // 如果没有当前任务，创建一个\n        currentTask.value = {\n          ...taskData,\n          updateTime: new Date().toISOString()\n        }\n        \n        console.log('创建的当前任务:', currentTask.value)\n        \n        // 保存到本地存储\n        await saveTaskToStorage(currentTask.value)\n        \n        // 添加到历史记录\n        addToHistory(currentTask.value)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('刷新任务状态失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 更新任务状态（简化版本，用于手动更新）\n   */\n  const updateTaskStatus = async () => {\n    if (currentTask.value?.taskId) {\n      return await refreshTaskStatus(currentTask.value.taskId)\n    }\n  }\n\n  /**\n   * 更新当前任务的属性\n   */\n  const updateCurrentTask = (updates) => {\n    if (currentTask.value) {\n      currentTask.value = {\n        ...currentTask.value,\n        ...updates,\n        updateTime: new Date().toISOString()\n      }\n      \n      // 保存到本地存储\n      saveTaskToStorage(currentTask.value)\n      \n      // 更新历史记录\n      updateHistoryItem(currentTask.value)\n    }\n  }\n\n  /**\n   * 开始轮询任务状态\n   */\n  const startPolling = (taskId) => {\n    // 先停止之前的轮询\n    stopPolling()\n    \n    pollingTimer.value = setInterval(async () => {\n      try {\n        await refreshTaskStatus(taskId)\n        \n        // 如果任务完成或失败，停止轮询\n        if (!isProcessing.value) {\n          stopPolling()\n        }\n      } catch (error) {\n        console.error('轮询任务状态失败:', error)\n        // 轮询失败也停止轮询\n        stopPolling()\n      }\n    }, 5000) // 每5秒轮询一次\n  }\n\n  /**\n   * 停止轮询\n   */\n  const stopPolling = () => {\n    if (pollingTimer.value) {\n      clearInterval(pollingTimer.value)\n      pollingTimer.value = null\n    }\n  }\n\n  /**\n   * 下载视频文件\n   */\n  const downloadVideo = async (taskId) => {\n    isDownloading.value = true\n    try {\n      const downloadUrl = await videoApi.getDownloadUrl(taskId)\n      \n      // 创建下载链接\n      const link = document.createElement('a')\n      link.href = downloadUrl\n      link.download = `video_${taskId}.mp4`\n      document.body.appendChild(link)\n      link.click()\n      document.body.removeChild(link)\n      \n      return true\n    } catch (error) {\n      console.error('下载视频失败:', error)\n      throw error\n    } finally {\n      isDownloading.value = false\n    }\n  }\n\n  /**\n   * 转换视频为文案\n   */\n  const transcribeVideo = async (taskId) => {\n    try {\n      // 设置转换状态\n      transcriptionData.value = {\n        taskId,\n        status: 'processing',\n        progress: 0,\n        createTime: new Date().toISOString()\n      }\n\n      // 1. 提交转文案任务（后端应立即返回处理中）\n      await videoApi.transcribeVideo(taskId)\n      // 2. 轮询获取最终结果\n      const result = await videoApi.pollTranscriptionResult(taskId)\n\n      // 更新转文案数据\n      transcriptionData.value = {\n        ...transcriptionData.value,\n        ...result,\n        status: 'completed'\n      }\n      return result\n    } catch (error) {\n      // 设置失败状态\n      if (transcriptionData.value) {\n        transcriptionData.value.status = 'failed'\n        transcriptionData.value.errorMessage = error.message\n      }\n      console.error('转换视频为文案失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 获取转文案结果\n   */\n  const getTranscriptionResult = async (taskId) => {\n    try {\n      const response = await videoApi.getTranscriptionResult(taskId)\n      \n      // 更新转文案数据\n      transcriptionData.value = {\n        ...transcriptionData.value,\n        ...response.transcription,\n        videoInfo: response.videoInfo\n      }\n      \n      return response\n    } catch (error) {\n      console.error('获取转文案结果失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * AI优化文案\n   */\n  const optimizeText = async (originalText, options = {}) => {\n    try {\n      const response = await videoApi.optimizeText(originalText, options)\n      return response\n    } catch (error) {\n      console.error('AI优化文案失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 清理当前任务\n   */\n  const cleanupCurrentTask = async () => {\n    if (currentTask.value) {\n      try {\n        await videoCleaner.cleanCurrentTask()\n        console.log('已清理当前任务缓存')\n      } catch (error) {\n        console.warn('清理当前任务失败:', error)\n      }\n    }\n  }\n\n  /**\n   * 取消/删除任务\n   */\n  const cancelTask = async (taskId) => {\n    try {\n      await videoApi.cleanVideo(taskId)\n      \n      // 如果是当前任务，清除状态\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value = null\n        videoCleaner.setCurrentTask(null)\n        stopPolling()\n      }\n      \n      // 从历史记录中移除\n      removeFromHistory(taskId)\n      \n      // 从本地存储中移除\n      await removeTaskFromStorage(taskId)\n      \n      return true\n    } catch (error) {\n      console.error('取消任务失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 删除任务（向后兼容）\n   */\n  const deleteTask = async (taskId) => {\n    return cancelTask(taskId)\n  }\n\n  /**\n   * 重试失败任务\n   */\n  const retryTask = async (taskId) => {\n    try {\n      const response = await videoApi.retryTask(taskId)\n      \n      // 如果是当前任务，开始轮询\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value.status = 'pending'\n        startPolling(taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('重试任务失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 重置当前任务状态\n   */\n  const resetCurrentTask = () => {\n    currentTask.value = null\n    transcriptionData.value = null\n    stopPolling()\n    videoCleaner.setCurrentTask(null)\n  }\n\n  /**\n   * 获取任务历史记录\n   */\n  const loadTaskHistory = async () => {\n    try {\n      const history = storage.get('taskHistory', [])\n      taskHistory.value = history\n      return history\n    } catch (error) {\n      console.error('加载任务历史失败:', error)\n      return []\n    }\n  }\n\n  /**\n   * 清除所有历史记录\n   */\n  const clearHistory = async () => {\n    try {\n      taskHistory.value = []\n      storage.remove('taskHistory')\n      return true\n    } catch (error) {\n      console.error('清除历史记录失败:', error)\n      throw error\n    }\n  }\n\n  // 辅助方法\n\n  /**\n   * 添加到历史记录\n   */\n  const addToHistory = (task) => {\n    const existingIndex = taskHistory.value.findIndex(item => item.taskId === task.taskId)\n    \n    if (existingIndex >= 0) {\n      // 更新已存在的记录\n      taskHistory.value[existingIndex] = { ...task, updateTime: new Date().toISOString() }\n    } else {\n      // 添加新记录，保持最新的在前面\n      taskHistory.value.unshift({ ...task, updateTime: new Date().toISOString() })\n      \n      // 限制历史记录数量\n      if (taskHistory.value.length > 50) {\n        taskHistory.value = taskHistory.value.slice(0, 50)\n      }\n    }\n    \n    // 保存到本地存储\n    storage.set('taskHistory', taskHistory.value)\n  }\n\n  /**\n   * 更新历史记录中的项目\n   */\n  const updateHistoryItem = (task) => {\n    const index = taskHistory.value.findIndex(item => item.taskId === task.taskId)\n    if (index >= 0) {\n      taskHistory.value[index] = { ...task, updateTime: new Date().toISOString() }\n      \n      // 保存到本地存储\n      storage.set('taskHistory', taskHistory.value)\n    }\n  }\n\n  /**\n   * 从历史记录中移除\n   */\n  const removeFromHistory = (taskId) => {\n    taskHistory.value = taskHistory.value.filter(item => item.taskId !== taskId)\n    \n    // 保存到本地存储\n    storage.set('taskHistory', taskHistory.value)\n  }\n\n  /**\n   * 保存任务到本地存储\n   */\n  const saveTaskToStorage = async (task) => {\n    try {\n      storage.set(`task_${task.taskId}`, task)\n    } catch (error) {\n      console.error('保存任务到本地存储失败:', error)\n    }\n  }\n\n  /**\n   * 从本地存储移除任务\n   */\n  const removeTaskFromStorage = async (taskId) => {\n    try {\n      storage.remove(`task_${taskId}`)\n    } catch (error) {\n      console.error('从本地存储移除任务失败:', error)\n    }\n  }\n\n  /**\n   * 从本地存储恢复任务\n   */\n  const restoreTaskFromStorage = async (taskId) => {\n    try {\n      const task = storage.get(`task_${taskId}`)\n      if (task) {\n        currentTask.value = task\n        return task\n      }\n      return null\n    } catch (error) {\n      console.error('从本地存储恢复任务失败:', error)\n      return null\n    }\n  }\n\n  // 初始化\n  const initialize = async () => {\n    try {\n      // 加载历史记录\n      await loadTaskHistory()\n    } catch (error) {\n      console.error('初始化任务存储失败:', error)\n    }\n  }\n\n  // 返回状态和方法\n  return {\n    // 状态\n    currentTask,\n    taskHistory,\n    isLoading,\n    isDownloading,\n    transcriptionData,\n    \n    // 计算属性\n    currentProgress,\n    isProcessing,\n    isCompleted,\n    isFailed,\n    isTranscribing,\n    isTranscriptionCompleted,\n    isTranscriptionFailed,\n    \n    // 方法\n    createTask,\n    createUploadTask,\n    refreshTaskStatus,\n    updateTaskStatus,\n    updateCurrentTask,\n    startPolling,\n    stopPolling,\n    downloadVideo,\n    transcribeVideo,\n    getTranscriptionResult,\n    optimizeText,\n    cancelTask,\n    deleteTask,\n    retryTask,\n    loadTaskHistory,\n    clearHistory,\n    restoreTaskFromStorage,\n    initialize,\n    cleanupCurrentTask,\n    resetCurrentTask\n  }\n}) ","/**\n * 剪贴板工具函数\n */\n\n/**\n * 复制文本到剪贴板\n * @param {string} text - 要复制的文本\n * @returns {Promise<boolean>} - 复制是否成功\n */\nexport async function copyToClipboard(text) {\n  try {\n    // 优先使用现代 Clipboard API\n    if (navigator.clipboard && window.isSecureContext) {\n      await navigator.clipboard.writeText(text)\n      return true\n    }\n    \n    // 降级到传统方法\n    const textArea = document.createElement('textarea')\n    textArea.value = text\n    textArea.style.position = 'fixed'\n    textArea.style.opacity = '0'\n    textArea.style.left = '-999999px'\n    textArea.style.top = '-999999px'\n    \n    document.body.appendChild(textArea)\n    textArea.focus()\n    textArea.select()\n    \n    const success = document.execCommand('copy')\n    document.body.removeChild(textArea)\n    \n    return success\n  } catch (error) {\n    console.error('复制到剪贴板失败:', error)\n    return false\n  }\n}\n\n/**\n * 从剪贴板读取文本\n * @returns {Promise<string>} - 剪贴板中的文本\n */\nexport async function readFromClipboard() {\n  try {\n    // 只有在安全上下文中才能使用 Clipboard API\n    if (navigator.clipboard && window.isSecureContext) {\n      const text = await navigator.clipboard.readText()\n      return text\n    }\n    \n    // 无法在非安全上下文中读取剪贴板\n    throw new Error('无法读取剪贴板：需要安全上下文')\n  } catch (error) {\n    console.error('读取剪贴板失败:', error)\n    return ''\n  }\n}\n\n/**\n * 检查是否支持剪贴板操作\n * @returns {boolean} - 是否支持剪贴板操作\n */\nexport function isClipboardSupported() {\n  return !!(navigator.clipboard && window.isSecureContext)\n}\n\n/**\n * 检查文本是否可能是视频链接\n * @param {string} text - 要检查的文本\n * @returns {boolean} - 是否可能是视频链接\n */\nexport function isPossibleVideoLink(text) {\n  if (!text || typeof text !== 'string') {\n    return false\n  }\n  \n  // 常见视频平台域名\n  const videoPatterns = [\n    /douyin\\.com/i,\n    /dy\\.com/i,\n    /bilibili\\.com/i,\n    /b23\\.tv/i,\n    /youtube\\.com/i,\n    /youtu\\.be/i,\n    /kuaishou\\.com/i,\n    /ixigua\\.com/i,\n    /weibo\\.com/i,\n    /xiaohongshu\\.com/i\n  ]\n  \n  // 检查是否包含视频平台域名\n  return videoPatterns.some(pattern => pattern.test(text))\n}\n\n/**\n * 提取文本中的链接\n * @param {string} text - 要提取链接的文本\n * @returns {string[]} - 提取到的链接数组\n */\nexport function extractLinks(text) {\n  if (!text || typeof text !== 'string') {\n    return []\n  }\n  \n  // URL正则表达式\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/gi\n  const matches = text.match(urlRegex)\n  \n  return matches || []\n}\n\n/**\n * 清理和标准化文本\n * @param {string} text - 要清理的文本\n * @returns {string} - 清理后的文本\n */\nexport function cleanText(text) {\n  if (!text || typeof text !== 'string') {\n    return ''\n  }\n  \n  return text\n    .trim()\n    .replace(/\\s+/g, ' ') // 合并多个空格\n    .replace(/[\\r\\n]+/g, ' ') // 换行符转空格\n} "],"names":["isDevelopment","API_BASE_URL","api","axios","config","showLoadingToast","_a","error","closeToast","response","data","errorMessage","showToast","status","FFMessageType","FFFSType","maybeCompressForNetlify","inputFile","thresholdBytes","videoApi","url","platform","file","onProgress","MAX_SIZE","supportedTypes","supportedExtensions","fileExtension","uploadFile","enableCompression","thresholdMb","compacted","compressed","compressedKey","e","formData","progressEvent","progress","_c","_b","_d","taskId","params","hours","text","options","trimmedText","MAX_LENGTH","timeout","CHUNK_SIZE","chunks","sentences","currentChunk","i","sentence","optimizedChunks","errors","resolve","optimizedText","interval","maxAttempts","attempts","res","VideoCleaner","shouldClean","cleanUrl","videoCleaner","storage","key","defaultValue","item","value","total","useTaskStore","defineStore","currentTask","ref","taskHistory","isLoading","isDownloading","pollingTimer","transcriptionData","currentProgress","computed","isProcessing","isCompleted","isFailed","isTranscribing","isTranscriptionCompleted","isTranscriptionFailed","createTask","cleanupCurrentTask","saveTaskToStorage","addToHistory","startPolling","createUploadTask","taskForStorage","refreshTaskStatus","taskData","updateHistoryItem","updateTaskStatus","updateCurrentTask","updates","stopPolling","downloadVideo","downloadUrl","link","transcribeVideo","result","getTranscriptionResult","optimizeText","originalText","cancelTask","removeFromHistory","removeTaskFromStorage","deleteTask","retryTask","resetCurrentTask","loadTaskHistory","history","clearHistory","task","existingIndex","index","copyToClipboard","textArea","success","readFromClipboard"],"mappings":"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","x_google_ignoreList":[1,2]}