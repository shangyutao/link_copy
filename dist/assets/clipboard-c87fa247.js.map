{"version":3,"file":"clipboard-c87fa247.js","sources":["../../src/services/api.js","../../src/services/video.js","../../src/utils/storage.js","../../src/stores/task.js","../../src/utils/clipboard.js"],"sourcesContent":["import axios from 'axios'\nimport { showToast, showLoadingToast, closeToast } from 'vant'\n\n// 环境配置\nconst isDevelopment = import.meta.env.DEV\nconst API_BASE_URL = isDevelopment \n  ? 'http://47.109.155.18:2222/api'  // 开发环境\n  : '/api'  // 生产环境使用相对路径\n\nconsole.log('API环境配置:', { isDevelopment, API_BASE_URL })\n\n// 创建axios实例\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n\n// 请求拦截器\napi.interceptors.request.use(\n  config => {\n    // 显示loading\n    if (config.showLoading !== false) {\n      showLoadingToast({\n        message: '请求中...',\n        forbidClick: true,\n        duration: 0\n      })\n    }\n    \n    console.log('API请求:', config.method?.toUpperCase(), config.url, config.data)\n    return config\n  },\n  error => {\n    closeToast()\n    console.error('请求错误:', error)\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\napi.interceptors.response.use(\n  response => {\n    closeToast()\n    \n    const { data } = response\n    console.log('API响应:', response.config.url, data)\n    \n    // 根据业务状态码处理\n    if (data.code && data.code !== 200) {\n      const errorMessage = data.message || '请求失败'\n      showToast({\n        type: 'fail',\n        message: errorMessage\n      })\n      return Promise.reject(new Error(errorMessage))\n    }\n    \n    return data\n  },\n  error => {\n    closeToast()\n    \n    console.error('响应错误:', error)\n    \n    let errorMessage = '网络错误，请稍后重试'\n    \n    if (error.response) {\n      const { status, data } = error.response\n      \n      switch (status) {\n        case 400:\n          errorMessage = data.message || '请求参数错误'\n          break\n        case 401:\n          errorMessage = '未授权，请重新登录'\n          break\n        case 403:\n          errorMessage = '没有权限访问'\n          break\n        case 404:\n          errorMessage = '请求的资源不存在'\n          break\n        case 408:\n          errorMessage = '请求超时'\n          break\n        case 500:\n          errorMessage = '服务器内部错误'\n          break\n        case 503:\n          errorMessage = '服务暂时不可用'\n          break\n        default:\n          if (data && data.message) {\n            errorMessage = data.message\n          }\n      }\n    } else if (error.code === 'ECONNABORTED') {\n      errorMessage = '请求超时，请检查网络连接'\n    } else if (error.message === 'Network Error') {\n      errorMessage = '网络连接异常'\n    }\n    \n    showToast({\n      type: 'fail',\n      message: errorMessage\n    })\n    \n    return Promise.reject(error)\n  }\n)\n\nexport default api\nexport { API_BASE_URL } ","import api from './api'\n\n/**\n * 视频相关API服务\n */\nexport const videoApi = {\n  /**\n   * 创建下载任务\n   * @param {string} url - 视频链接\n   * @param {string} platform - 平台名称（可选）\n   * @returns {Promise<Object>} 任务信息\n   */\n  async createDownloadTask(url, platform = null) {\n    const response = await api.post('/video/download', {\n      url,\n      platform\n    })\n    return response.data\n  },\n\n  /**\n   * 上传视频文件\n   * @param {File} file - 视频文件\n   * @param {Function} onProgress - 上传进度回调\n   * @returns {Promise<Object>} 任务信息\n   */\n  async uploadVideoFile(file, onProgress = null) {\n    // 参数验证\n    if (!file || !(file instanceof File)) {\n      throw new Error('请选择有效的视频文件')\n    }\n\n    // 文件大小验证（500MB限制）\n    const MAX_SIZE = 500 * 1024 * 1024 // 500MB\n    if (file.size > MAX_SIZE) {\n      throw new Error(`文件大小不能超过500MB，当前文件大小：${this.formatFileSize(file.size)}`)\n    }\n\n    // 文件类型验证\n    const supportedTypes = [\n      'video/mp4', 'video/avi', 'video/quicktime', 'video/x-msvideo',\n      'video/x-flv', 'video/webm', 'video/x-matroska', 'video/mp4v-es',\n      'video/3gpp', 'video/ogg'\n    ]\n    \n    const supportedExtensions = [\n      '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv', '.m4v', '.3gp', '.ogv'\n    ]\n    \n    const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'))\n    \n    if (!supportedTypes.includes(file.type) && !supportedExtensions.includes(fileExtension)) {\n      throw new Error('不支持的视频格式，请上传 MP4、AVI、MOV、WMV、FLV、WEBM、MKV、M4V、3GP、OGV 格式的视频文件')\n    }\n\n    // 创建FormData\n    const formData = new FormData()\n    formData.append('video', file)\n\n    // 配置请求选项\n    const config = {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      },\n      timeout: 300000, // 5分钟超时\n      onUploadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)\n          onProgress(progress)\n        }\n      }\n    }\n\n    try {\n      const response = await api.post('/video/upload', formData, config)\n      return response.data\n    } catch (error) {\n      if (error.code === 'ECONNABORTED') {\n        throw new Error('上传超时，请检查网络连接或尝试上传更小的文件')\n      }\n      if (error.response?.status === 413) {\n        throw new Error('文件过大，请上传小于500MB的视频文件')\n      }\n      throw error\n    }\n  },\n\n  /**\n   * 查询任务状态\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 任务状态信息\n   */\n  async getTaskStatus(taskId) {\n    const response = await api.get(`/video/status/${taskId}`, {\n      showLoading: false // 轮询时不显示loading\n    })\n    return response.data\n  },\n\n  /**\n   * 获取视频文件下载链接\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<string>} 下载链接\n   */\n  async getDownloadUrl(taskId) {\n    // 返回直接下载链接\n    return `${api.defaults.baseURL}/video/file/${taskId}`\n  },\n\n  /**\n   * 清理视频文件（立即删除）\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 删除结果\n   */\n  async cleanVideo(taskId) {\n    const response = await api.delete(`/video/clean/${taskId}`, {\n      showLoading: false // 避免显示loading，因为清理操作通常在后台进行\n    })\n    return response.data\n  },\n\n  /**\n   * 删除视频文件 (向后兼容)\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 删除结果\n   */\n  async deleteTask(taskId) {\n    return this.cleanVideo(taskId)\n  },\n\n  /**\n   * 获取支持的平台列表\n   * @returns {Promise<Object>} 平台列表\n   */\n  async getSupportedPlatforms() {\n    const response = await api.get('/video/platforms')\n    return response.data\n  },\n\n  /**\n   * 获取任务列表\n   * @param {Object} params - 查询参数\n   * @returns {Promise<Object>} 任务列表\n   */\n  async getTaskList(params = {}) {\n    const response = await api.get('/video/tasks', { params })\n    return response.data\n  },\n\n  /**\n   * 获取系统统计信息\n   * @returns {Promise<Object>} 统计信息\n   */\n  async getStats() {\n    const response = await api.get('/video/stats')\n    return response.data\n  },\n\n  /**\n   * 批量清理过期文件\n   * @param {number} hours - 过期小时数\n   * @returns {Promise<Object>} 清理结果\n   */\n  async cleanExpiredFiles(hours = 24) {\n    const response = await api.post('/video/clean/expired', {\n      hours\n    })\n    return response.data\n  },\n\n  /**\n   * 重试失败任务\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 重试结果\n   */\n  async retryTask(taskId) {\n    const response = await api.post(`/video/retry/${taskId}`)\n    return response.data\n  },\n\n  /**\n   * 获取视频预览信息\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 预览信息\n   */\n  async getVideoPreview(taskId) {\n    const response = await api.get(`/video/preview/${taskId}`)\n    return response\n  },\n\n  /**\n   * 视频音频转文案\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 转文案结果\n   */\n  async transcribeVideo(taskId) {\n    const response = await api.post(`/video/transcribe/${taskId}`)\n    return response.data\n  },\n\n  /**\n   * AI优化文案\n   * @param {string} text - 原始文案\n   * @param {Object} options - 优化选项\n   * @returns {Promise<Object>} 优化结果\n   */\n  async optimizeText(text, options = {}) {\n    // 参数验证\n    if (!text || typeof text !== 'string') {\n      throw new Error('文案内容不能为空')\n    }\n    \n    const trimmedText = text.trim()\n    if (trimmedText.length === 0) {\n      throw new Error('文案内容不能为空')\n    }\n    \n    // 检查字符长度限制\n    const MAX_LENGTH = 10000\n    if (trimmedText.length > MAX_LENGTH) {\n      throw new Error(`文案长度不能超过${MAX_LENGTH}字符，当前长度：${trimmedText.length}`)\n    }\n    \n    // 设置超时时间（接口文档要求至少120秒）\n    const timeout = options.timeout || 120000 // 120秒\n    \n    // 如果文案较长，需要分段处理\n    const CHUNK_SIZE = 1500\n    if (trimmedText.length > CHUNK_SIZE) {\n      return await this._optimizeTextInChunks(trimmedText, timeout)\n    }\n    \n    // 单段处理\n    try {\n      const response = await api.post('/video/optimize-text', {\n        text: trimmedText\n      }, {\n        timeout,\n        showLoading: options.showLoading !== false\n      })\n      return response.data\n    } catch (error) {\n      if (error.code === 'ECONNABORTED' || error.response?.status === 408) {\n        throw new Error('AI优化请求超时，建议将长文案分段提交')\n      }\n      throw error\n    }\n  },\n\n  /**\n   * 分段优化文案（私有方法）\n   * @param {string} text - 原始文案\n   * @param {number} timeout - 超时时间\n   * @returns {Promise<Object>} 优化结果\n   */\n  async _optimizeTextInChunks(text, timeout) {\n    const CHUNK_SIZE = 1500\n    const chunks = []\n    \n    // 按句号、问号、感叹号等自然断句分段\n    const sentences = text.split(/([。！？\\.\\!\\?]+)/)\n    let currentChunk = ''\n    \n    for (let i = 0; i < sentences.length; i++) {\n      const sentence = sentences[i]\n      \n      if (currentChunk.length + sentence.length <= CHUNK_SIZE) {\n        currentChunk += sentence\n      } else {\n        if (currentChunk.trim()) {\n          chunks.push(currentChunk.trim())\n        }\n        currentChunk = sentence\n      }\n    }\n    \n    // 添加最后一段\n    if (currentChunk.trim()) {\n      chunks.push(currentChunk.trim())\n    }\n    \n    // 如果没有合适的断句，强制按字符数分段\n    if (chunks.length === 1 && chunks[0].length > CHUNK_SIZE) {\n      chunks.length = 0\n      for (let i = 0; i < text.length; i += CHUNK_SIZE) {\n        chunks.push(text.slice(i, i + CHUNK_SIZE))\n      }\n    }\n    \n    console.log(`文案分为${chunks.length}段进行优化`)\n    \n    // 逐段优化\n    const optimizedChunks = []\n    const errors = []\n    \n    for (let i = 0; i < chunks.length; i++) {\n      try {\n        console.log(`正在优化第${i + 1}/${chunks.length}段...`)\n        const response = await api.post('/video/optimize-text', {\n          text: chunks[i]\n        }, {\n          timeout,\n          showLoading: false // 分段时不显示loading，避免频繁弹窗\n        })\n        \n        optimizedChunks.push(response.data.optimizedText || chunks[i])\n        \n        // 分段之间添加小延迟，避免请求过于频繁\n        if (i < chunks.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000))\n        }\n      } catch (error) {\n        console.error(`第${i + 1}段优化失败:`, error)\n        errors.push(`第${i + 1}段: ${error.message}`)\n        optimizedChunks.push(chunks[i]) // 使用原文\n      }\n    }\n    \n    // 合并结果\n    const optimizedText = optimizedChunks.join('')\n    \n    return {\n      originalText: text,\n      optimizedText,\n      optimizationTime: new Date().toISOString(),\n      model: 'doubao-seed-1-6-250615',\n      chunks: chunks.length,\n      errors: errors.length > 0 ? errors : undefined\n    }\n  },\n\n  /**\n   * 获取转文案结果\n   * @param {string} taskId - 任务ID\n   * @returns {Promise<Object>} 转文案结果\n   */\n  async getTranscriptionResult(taskId) {\n    const response = await api.get(`/video/transcription/${taskId}`, {\n      showLoading: false // 轮询时不显示loading\n    })\n    return response.data\n  }\n}\n\n/**\n * 任务轮询器类\n */\nexport class TaskPoller {\n  constructor(taskId, onUpdate, options = {}) {\n    this.taskId = taskId\n    this.onUpdate = onUpdate\n    this.options = {\n      interval: 3000, // 轮询间隔（毫秒）\n      maxAttempts: 100, // 最大尝试次数\n      onError: null, // 错误回调\n      onComplete: null, // 完成回调\n      onFailed: null, // 失败回调\n      ...options\n    }\n    \n    this.isRunning = false\n    this.attempts = 0\n    this.timer = null\n  }\n\n  /**\n   * 开始轮询\n   */\n  start() {\n    if (this.isRunning) {\n      return\n    }\n    \n    this.isRunning = true\n    this.attempts = 0\n    this.poll()\n  }\n\n  /**\n   * 停止轮询\n   */\n  stop() {\n    this.isRunning = false\n    this.attempts = 0\n    \n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  /**\n   * 执行轮询\n   */\n  async poll() {\n    if (!this.isRunning) {\n      return\n    }\n\n    this.attempts++\n\n    try {\n      const result = await videoApi.getTaskStatus(this.taskId)\n      \n      // 调用更新回调\n      if (this.onUpdate) {\n        this.onUpdate(result)\n      }\n\n      // 检查任务状态\n      if (result.status === 'completed') {\n        this.stop()\n        if (this.options.onComplete) {\n          this.options.onComplete(result)\n        }\n        return\n      }\n\n      if (result.status === 'failed') {\n        this.stop()\n        if (this.options.onFailed) {\n          this.options.onFailed(result)\n        }\n        return\n      }\n\n      // 检查是否超过最大尝试次数\n      if (this.attempts >= this.options.maxAttempts) {\n        this.stop()\n        const error = new Error(`轮询超时：已尝试 ${this.attempts} 次`)\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n        return\n      }\n\n      // 继续轮询\n      this.timer = setTimeout(() => {\n        this.poll()\n      }, this.options.interval)\n\n    } catch (error) {\n      console.error('轮询任务状态失败:', error)\n      \n      // 如果是网络错误，继续尝试\n      if (this.attempts < this.options.maxAttempts) {\n        this.timer = setTimeout(() => {\n          this.poll()\n        }, this.options.interval)\n      } else {\n        this.stop()\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n      }\n    }\n  }\n}\n\n/**\n * 转文案轮询器类\n */\nexport class TranscriptionPoller {\n  constructor(taskId, onUpdate, options = {}) {\n    this.taskId = taskId\n    this.onUpdate = onUpdate\n    this.options = {\n      interval: 2000, // 轮询间隔（毫秒）\n      maxAttempts: 150, // 最大尝试次数（5分钟）\n      onError: null,\n      onComplete: null,\n      onFailed: null,\n      ...options\n    }\n    \n    this.isRunning = false\n    this.attempts = 0\n    this.timer = null\n  }\n\n  /**\n   * 开始轮询\n   */\n  start() {\n    if (this.isRunning) {\n      return\n    }\n    \n    this.isRunning = true\n    this.attempts = 0\n    this.poll()\n  }\n\n  /**\n   * 停止轮询\n   */\n  stop() {\n    this.isRunning = false\n    this.attempts = 0\n    \n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  /**\n   * 执行轮询\n   */\n  async poll() {\n    if (!this.isRunning) {\n      return\n    }\n\n    this.attempts++\n\n    try {\n      const result = await videoApi.getTranscriptionResult(this.taskId)\n      \n      // 调用更新回调\n      if (this.onUpdate) {\n        this.onUpdate(result)\n      }\n\n      // 检查转文案状态\n      if (result.transcription && result.transcription.status === 'completed') {\n        this.stop()\n        if (this.options.onComplete) {\n          this.options.onComplete(result)\n        }\n        return\n      }\n\n      if (result.transcription && result.transcription.status === 'failed') {\n        this.stop()\n        if (this.options.onFailed) {\n          this.options.onFailed(result)\n        }\n        return\n      }\n\n      // 检查是否超过最大尝试次数\n      if (this.attempts >= this.options.maxAttempts) {\n        this.stop()\n        const error = new Error(`转文案轮询超时：已尝试 ${this.attempts} 次`)\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n        return\n      }\n\n      // 继续轮询\n      this.timer = setTimeout(() => {\n        this.poll()\n      }, this.options.interval)\n\n    } catch (error) {\n      console.error('轮询转文案状态失败:', error)\n      \n      // 404错误可能表示转文案还未开始或不存在\n      if (error.response?.status === 404) {\n        // 继续轮询\n        if (this.attempts < this.options.maxAttempts) {\n          this.timer = setTimeout(() => {\n            this.poll()\n          }, this.options.interval)\n        } else {\n          this.stop()\n          if (this.options.onError) {\n            this.options.onError(new Error('转文案任务不存在'))\n          }\n        }\n      } else {\n        // 其他错误，停止轮询\n        this.stop()\n        if (this.options.onError) {\n          this.options.onError(error)\n        }\n      }\n    }\n  }\n}\n\n/**\n * 视频服务工具函数\n */\nexport const videoUtils = {\n  /**\n   * 检测视频平台\n   * @param {string} url - 视频链接\n   * @returns {string|null} 平台名称\n   */\n  detectPlatform(url) {\n    if (!url) return null\n    \n    const platformMap = {\n      'douyin.com': 'douyin',\n      'dy.com': 'douyin',\n      'bilibili.com': 'bilibili',\n      'b23.tv': 'bilibili',\n      'youtube.com': 'youtube',\n      'youtu.be': 'youtube',\n      'kuaishou.com': 'kuaishou',\n      'ixigua.com': 'ixigua'\n    }\n    \n    for (const [domain, platform] of Object.entries(platformMap)) {\n      if (url.includes(domain)) {\n        return platform\n      }\n    }\n    \n    return null\n  },\n\n  /**\n   * 验证视频链接\n   * @param {string} url - 视频链接\n   * @returns {boolean} 是否有效\n   */\n  isValidVideoUrl(url) {\n    if (!url || typeof url !== 'string') {\n      return false\n    }\n    \n    // 简单的URL验证\n    try {\n      new URL(url)\n      return this.detectPlatform(url) !== null\n    } catch {\n      return false\n    }\n  },\n\n  /**\n   * 清理视频链接\n   * @param {string} url - 原始链接\n   * @returns {string} 清理后的链接\n   */\n  cleanVideoUrl(url) {\n    if (!url) return ''\n    \n    // 移除多余的空格和换行符\n    url = url.trim().replace(/\\s+/g, ' ')\n    \n    // 提取URL\n    const urlMatch = url.match(/(https?:\\/\\/[^\\s]+)/i)\n    if (urlMatch) {\n      return urlMatch[1]\n    }\n    \n    return url\n  },\n\n  /**\n   * 格式化文件大小\n   * @param {number} bytes - 字节数\n   * @returns {string} 格式化后的大小\n   */\n  formatFileSize(bytes) {\n    if (!bytes) return '0 B'\n    \n    const units = ['B', 'KB', 'MB', 'GB']\n    let size = bytes\n    let unitIndex = 0\n    \n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024\n      unitIndex++\n    }\n    \n    return `${size.toFixed(1)} ${units[unitIndex]}`\n  },\n\n  /**\n   * 获取平台显示名称\n   * @param {string} platform - 平台代码\n   * @returns {string} 显示名称\n   */\n  getPlatformDisplayName(platform) {\n    const nameMap = {\n      'douyin': '抖音',\n      'bilibili': '哔哩哔哩',\n      'youtube': 'YouTube',\n      'kuaishou': '快手',\n      'ixigua': '西瓜视频'\n    }\n    \n    return nameMap[platform] || platform || '未知平台'\n  },\n\n  /**\n   * 获取平台颜色\n   * @param {string} platform - 平台代码\n   * @returns {string} 颜色值\n   */\n  getPlatformColor(platform) {\n    const colorMap = {\n      'douyin': '#ff6b6b',\n      'bilibili': '#fb7299',\n      'youtube': '#ff0000',\n      'kuaishou': '#ff6600',\n      'ixigua': '#20b2aa'\n    }\n    \n    return colorMap[platform] || '#666eea'\n  }\n}\n\n/**\n * 视频清理管理器\n */\nexport class VideoCleaner {\n  constructor() {\n    this.currentTaskId = null\n    this.shouldCleanOnUnload = true\n    this.setupCleanupListeners()\n  }\n\n  /**\n   * 设置当前任务ID\n   * @param {string} taskId - 任务ID\n   */\n  setCurrentTask(taskId) {\n    // 清理之前的任务\n    if (this.currentTaskId && this.currentTaskId !== taskId) {\n      this.cleanTask(this.currentTaskId)\n    }\n    this.currentTaskId = taskId\n  }\n\n  /**\n   * 清理指定任务\n   * @param {string} taskId - 任务ID\n   */\n  async cleanTask(taskId) {\n    if (!taskId) return\n    \n    try {\n      await videoApi.cleanVideo(taskId)\n      console.log(`已清理视频缓存: ${taskId}`)\n    } catch (error) {\n      console.warn(`清理视频缓存失败: ${taskId}`, error)\n    }\n  }\n\n  /**\n   * 清理当前任务\n   */\n  async cleanCurrentTask() {\n    if (this.currentTaskId) {\n      await this.cleanTask(this.currentTaskId)\n      this.currentTaskId = null\n    }\n  }\n\n  /**\n   * 设置页面卸载时是否自动清理\n   * @param {boolean} shouldClean - 是否清理\n   */\n  setShouldCleanOnUnload(shouldClean) {\n    this.shouldCleanOnUnload = shouldClean\n  }\n\n  /**\n   * 设置清理监听器\n   */\n  setupCleanupListeners() {\n    // 页面刷新或关闭时清理\n    window.addEventListener('beforeunload', () => {\n      if (this.shouldCleanOnUnload && this.currentTaskId) {\n        // 使用 navigator.sendBeacon 确保清理请求能够发送\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n\n    // 页面隐藏时清理（移动端兼容）\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden' && this.shouldCleanOnUnload && this.currentTaskId) {\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n\n    // 浏览器导航离开时清理\n    window.addEventListener('pagehide', () => {\n      if (this.shouldCleanOnUnload && this.currentTaskId) {\n        const cleanUrl = `${api.defaults.baseURL}/video/clean/${this.currentTaskId}`\n        navigator.sendBeacon(cleanUrl, JSON.stringify({ method: 'DELETE' }))\n      }\n    })\n  }\n}\n\n// 创建全局清理器实例\nexport const videoCleaner = new VideoCleaner() ","// 本地存储键名常量\nexport const STORAGE_KEYS = {\n  TASK_HISTORY: 'link_copy_task_history',\n  USER_SETTINGS: 'link_copy_user_settings',\n  RECENT_PLATFORMS: 'link_copy_recent_platforms'\n}\n\n// 安全的本地存储操作\nexport const storage = {\n  // 获取数据\n  get(key, defaultValue = null) {\n    try {\n      const item = localStorage.getItem(key)\n      return item ? JSON.parse(item) : defaultValue\n    } catch (error) {\n      console.error('读取本地存储失败:', error)\n      return defaultValue\n    }\n  },\n\n  // 设置数据\n  set(key, value) {\n    try {\n      localStorage.setItem(key, JSON.stringify(value))\n      return true\n    } catch (error) {\n      console.error('保存到本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 删除数据\n  remove(key) {\n    try {\n      localStorage.removeItem(key)\n      return true\n    } catch (error) {\n      console.error('删除本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 清空所有数据\n  clear() {\n    try {\n      localStorage.clear()\n      return true\n    } catch (error) {\n      console.error('清空本地存储失败:', error)\n      return false\n    }\n  },\n\n  // 获取存储大小\n  getSize() {\n    try {\n      let total = 0\n      for (let key in localStorage) {\n        if (localStorage.hasOwnProperty(key)) {\n          total += localStorage[key].length + key.length\n        }\n      }\n      return total\n    } catch (error) {\n      console.error('计算存储大小失败:', error)\n      return 0\n    }\n  }\n}\n\n// 任务历史相关操作\nexport const taskHistory = {\n  // 获取历史记录\n  getHistory() {\n    return storage.get(STORAGE_KEYS.TASK_HISTORY, [])\n  },\n\n  // 添加到历史记录\n  addTask(task) {\n    const history = this.getHistory()\n    \n    // 检查是否已存在\n    const existingIndex = history.findIndex(item => item.taskId === task.taskId)\n    \n    if (existingIndex >= 0) {\n      // 更新现有记录\n      history[existingIndex] = { ...history[existingIndex], ...task }\n    } else {\n      // 添加新记录到开头\n      history.unshift(task)\n    }\n    \n    // 限制历史记录数量\n    const limitedHistory = history.slice(0, 50)\n    \n    return storage.set(STORAGE_KEYS.TASK_HISTORY, limitedHistory)\n  },\n\n  // 更新任务\n  updateTask(taskId, updateData) {\n    const history = this.getHistory()\n    const index = history.findIndex(item => item.taskId === taskId)\n    \n    if (index >= 0) {\n      history[index] = { ...history[index], ...updateData }\n      return storage.set(STORAGE_KEYS.TASK_HISTORY, history)\n    }\n    \n    return false\n  },\n\n  // 删除任务\n  removeTask(taskId) {\n    const history = this.getHistory()\n    const filteredHistory = history.filter(item => item.taskId !== taskId)\n    \n    return storage.set(STORAGE_KEYS.TASK_HISTORY, filteredHistory)\n  },\n\n  // 清空历史记录\n  clearHistory() {\n    return storage.set(STORAGE_KEYS.TASK_HISTORY, [])\n  }\n}\n\n// 用户设置相关操作\nexport const userSettings = {\n  // 获取设置\n  getSettings() {\n    return storage.get(STORAGE_KEYS.USER_SETTINGS, {\n      autoDownload: false,\n      videoQuality: 'high',\n      saveHistory: true,\n      notifications: true\n    })\n  },\n\n  // 更新设置\n  updateSettings(newSettings) {\n    const currentSettings = this.getSettings()\n    const updatedSettings = { ...currentSettings, ...newSettings }\n    \n    return storage.set(STORAGE_KEYS.USER_SETTINGS, updatedSettings)\n  },\n\n  // 重置设置\n  resetSettings() {\n    return storage.remove(STORAGE_KEYS.USER_SETTINGS)\n  }\n} ","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport { videoApi, videoCleaner } from '@/services/video'\nimport { storage, taskHistory as storageTaskHistory } from '@/utils/storage'\n\nexport const useTaskStore = defineStore('task', () => {\n  // 响应式状态\n  const currentTask = ref(null)\n  const taskHistory = ref([])\n  const isLoading = ref(false)\n  const isDownloading = ref(false) // 下载状态\n  const pollingTimer = ref(null)\n  const transcriptionData = ref(null) // 转文案数据\n\n  // 计算属性\n  const currentProgress = computed(() => {\n    return currentTask.value?.progress || 0\n  })\n\n  const isProcessing = computed(() => {\n    const status = currentTask.value?.status\n    return status === 'pending' || status === 'downloading'\n  })\n\n  const isCompleted = computed(() => {\n    return currentTask.value?.status === 'completed'\n  })\n\n  const isFailed = computed(() => {\n    return currentTask.value?.status === 'failed'\n  })\n\n  // 转文案相关状态\n  const isTranscribing = computed(() => {\n    return transcriptionData.value?.status === 'processing'\n  })\n\n  const isTranscriptionCompleted = computed(() => {\n    return transcriptionData.value?.status === 'completed'\n  })\n\n  const isTranscriptionFailed = computed(() => {\n    return transcriptionData.value?.status === 'failed'\n  })\n\n  // 动作方法\n  \n  /**\n   * 创建下载任务\n   */\n  const createTask = async (url, platform = null) => {\n    isLoading.value = true\n    \n    try {\n      // 先清理之前的任务\n      await cleanupCurrentTask()\n      \n      const response = await videoApi.createDownloadTask(url, platform)\n      \n      // 设置当前任务\n      currentTask.value = {\n        taskId: response.taskId,\n        originalUrl: url,\n        platform: response.platform,\n        status: response.status,\n        progress: 0,\n        createTime: response.createTime,\n        isExisting: response.isExisting\n      }\n      \n      // 设置清理器的当前任务\n      videoCleaner.setCurrentTask(response.taskId)\n      \n      // 保存到本地存储\n      await saveTaskToStorage(currentTask.value)\n      \n      // 添加到历史记录\n      addToHistory(currentTask.value)\n      \n      // 开始轮询状态\n      if (isProcessing.value) {\n        startPolling(response.taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('创建任务失败:', error)\n      throw error\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  /**\n   * 创建文件上传任务\n   */\n  const createUploadTask = async (file, onProgress = null) => {\n    isLoading.value = true\n    \n    try {\n      // 先清理之前的任务\n      await cleanupCurrentTask()\n      \n      const response = await videoApi.uploadVideoFile(file, onProgress)\n      \n      // 设置当前任务\n      currentTask.value = {\n        taskId: response.taskId,\n        originalFile: file,\n        fileName: file.name,\n        fileSize: file.size,\n        platform: 'upload', // 标记为上传类型\n        status: response.status,\n        progress: 0,\n        createTime: response.createTime || new Date().toISOString(),\n        isExisting: response.isExisting || false\n      }\n      \n      // 设置清理器的当前任务\n      videoCleaner.setCurrentTask(response.taskId)\n      \n      // 保存到本地存储（不保存文件对象）\n      const taskForStorage = {\n        ...currentTask.value,\n        originalFile: null // 不保存文件对象到localStorage\n      }\n      await saveTaskToStorage(taskForStorage)\n      \n      // 添加到历史记录\n      addToHistory(taskForStorage)\n      \n      // 开始轮询状态\n      if (isProcessing.value) {\n        startPolling(response.taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('创建上传任务失败:', error)\n      throw error\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  /**\n   * 刷新任务状态\n   */\n  const refreshTaskStatus = async (taskId) => {\n    try {\n      const response = await videoApi.getTaskStatus(taskId)\n      console.log('API返回的任务状态:', response)\n      \n      // API响应结构：{code: 200, message: \"查询成功\", data: {...}}\n      // API拦截器返回response.data，即{code, message, data}\n      // 我们需要的实际任务数据在response.data字段中\n      const taskData = response.data || response\n      \n      console.log('提取的任务数据:', taskData)\n      console.log('任务进度:', taskData.progress)\n      \n      // 更新当前任务状态\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value = {\n          ...currentTask.value,\n          ...taskData,\n          updateTime: new Date().toISOString()\n        }\n        \n        console.log('更新后的任务状态:', currentTask.value)\n        \n        // 保存到本地存储\n        await saveTaskToStorage(currentTask.value)\n        \n        // 更新历史记录\n        updateHistoryItem(currentTask.value)\n      } else if (!currentTask.value) {\n        // 如果没有当前任务，创建一个\n        currentTask.value = {\n          ...taskData,\n          updateTime: new Date().toISOString()\n        }\n        \n        console.log('创建的当前任务:', currentTask.value)\n        \n        // 保存到本地存储\n        await saveTaskToStorage(currentTask.value)\n        \n        // 添加到历史记录\n        addToHistory(currentTask.value)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('刷新任务状态失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 更新任务状态（简化版本，用于手动更新）\n   */\n  const updateTaskStatus = async () => {\n    if (currentTask.value?.taskId) {\n      return await refreshTaskStatus(currentTask.value.taskId)\n    }\n  }\n\n  /**\n   * 更新当前任务的属性\n   */\n  const updateCurrentTask = (updates) => {\n    if (currentTask.value) {\n      currentTask.value = {\n        ...currentTask.value,\n        ...updates,\n        updateTime: new Date().toISOString()\n      }\n      \n      // 保存到本地存储\n      saveTaskToStorage(currentTask.value)\n      \n      // 更新历史记录\n      updateHistoryItem(currentTask.value)\n    }\n  }\n\n  /**\n   * 开始轮询任务状态\n   */\n  const startPolling = (taskId) => {\n    // 先停止之前的轮询\n    stopPolling()\n    \n    pollingTimer.value = setInterval(async () => {\n      try {\n        await refreshTaskStatus(taskId)\n        \n        // 如果任务完成或失败，停止轮询\n        if (!isProcessing.value) {\n          stopPolling()\n        }\n      } catch (error) {\n        console.error('轮询任务状态失败:', error)\n        // 轮询失败也停止轮询\n        stopPolling()\n      }\n    }, 5000) // 每5秒轮询一次\n  }\n\n  /**\n   * 停止轮询\n   */\n  const stopPolling = () => {\n    if (pollingTimer.value) {\n      clearInterval(pollingTimer.value)\n      pollingTimer.value = null\n    }\n  }\n\n  /**\n   * 下载视频文件\n   */\n  const downloadVideo = async (taskId) => {\n    isDownloading.value = true\n    try {\n      const downloadUrl = await videoApi.getDownloadUrl(taskId)\n      \n      // 创建下载链接\n      const link = document.createElement('a')\n      link.href = downloadUrl\n      link.download = `video_${taskId}.mp4`\n      document.body.appendChild(link)\n      link.click()\n      document.body.removeChild(link)\n      \n      return true\n    } catch (error) {\n      console.error('下载视频失败:', error)\n      throw error\n    } finally {\n      isDownloading.value = false\n    }\n  }\n\n  /**\n   * 转换视频为文案\n   */\n  const transcribeVideo = async (taskId) => {\n    try {\n      // 设置转换状态\n      transcriptionData.value = {\n        taskId,\n        status: 'processing',\n        progress: 0,\n        createTime: new Date().toISOString()\n      }\n      \n      const response = await videoApi.transcribeVideo(taskId)\n      \n      // 更新转文案数据\n      transcriptionData.value = {\n        ...transcriptionData.value,\n        ...response,\n        status: 'completed'\n      }\n      \n      return response\n    } catch (error) {\n      // 设置失败状态\n      if (transcriptionData.value) {\n        transcriptionData.value.status = 'failed'\n        transcriptionData.value.errorMessage = error.message\n      }\n      \n      console.error('转换视频为文案失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 获取转文案结果\n   */\n  const getTranscriptionResult = async (taskId) => {\n    try {\n      const response = await videoApi.getTranscriptionResult(taskId)\n      \n      // 更新转文案数据\n      transcriptionData.value = {\n        ...transcriptionData.value,\n        ...response.transcription,\n        videoInfo: response.videoInfo\n      }\n      \n      return response\n    } catch (error) {\n      console.error('获取转文案结果失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * AI优化文案\n   */\n  const optimizeText = async (originalText, options = {}) => {\n    try {\n      const response = await videoApi.optimizeText(originalText, options)\n      return response\n    } catch (error) {\n      console.error('AI优化文案失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 清理当前任务\n   */\n  const cleanupCurrentTask = async () => {\n    if (currentTask.value) {\n      try {\n        await videoCleaner.cleanCurrentTask()\n        console.log('已清理当前任务缓存')\n      } catch (error) {\n        console.warn('清理当前任务失败:', error)\n      }\n    }\n  }\n\n  /**\n   * 取消/删除任务\n   */\n  const cancelTask = async (taskId) => {\n    try {\n      await videoApi.cleanVideo(taskId)\n      \n      // 如果是当前任务，清除状态\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value = null\n        videoCleaner.setCurrentTask(null)\n        stopPolling()\n      }\n      \n      // 从历史记录中移除\n      removeFromHistory(taskId)\n      \n      // 从本地存储中移除\n      await removeTaskFromStorage(taskId)\n      \n      return true\n    } catch (error) {\n      console.error('取消任务失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 删除任务（向后兼容）\n   */\n  const deleteTask = async (taskId) => {\n    return cancelTask(taskId)\n  }\n\n  /**\n   * 重试失败任务\n   */\n  const retryTask = async (taskId) => {\n    try {\n      const response = await videoApi.retryTask(taskId)\n      \n      // 如果是当前任务，开始轮询\n      if (currentTask.value && currentTask.value.taskId === taskId) {\n        currentTask.value.status = 'pending'\n        startPolling(taskId)\n      }\n      \n      return response\n    } catch (error) {\n      console.error('重试任务失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 重置当前任务状态\n   */\n  const resetCurrentTask = () => {\n    currentTask.value = null\n    transcriptionData.value = null\n    stopPolling()\n    videoCleaner.setCurrentTask(null)\n  }\n\n  /**\n   * 获取任务历史记录\n   */\n  const loadTaskHistory = async () => {\n    try {\n      const history = storage.get('taskHistory', [])\n      taskHistory.value = history\n      return history\n    } catch (error) {\n      console.error('加载任务历史失败:', error)\n      return []\n    }\n  }\n\n  /**\n   * 清除所有历史记录\n   */\n  const clearHistory = async () => {\n    try {\n      taskHistory.value = []\n      storage.remove('taskHistory')\n      return true\n    } catch (error) {\n      console.error('清除历史记录失败:', error)\n      throw error\n    }\n  }\n\n  // 辅助方法\n\n  /**\n   * 添加到历史记录\n   */\n  const addToHistory = (task) => {\n    const existingIndex = taskHistory.value.findIndex(item => item.taskId === task.taskId)\n    \n    if (existingIndex >= 0) {\n      // 更新已存在的记录\n      taskHistory.value[existingIndex] = { ...task, updateTime: new Date().toISOString() }\n    } else {\n      // 添加新记录，保持最新的在前面\n      taskHistory.value.unshift({ ...task, updateTime: new Date().toISOString() })\n      \n      // 限制历史记录数量\n      if (taskHistory.value.length > 50) {\n        taskHistory.value = taskHistory.value.slice(0, 50)\n      }\n    }\n    \n    // 保存到本地存储\n    storage.set('taskHistory', taskHistory.value)\n  }\n\n  /**\n   * 更新历史记录中的项目\n   */\n  const updateHistoryItem = (task) => {\n    const index = taskHistory.value.findIndex(item => item.taskId === task.taskId)\n    if (index >= 0) {\n      taskHistory.value[index] = { ...task, updateTime: new Date().toISOString() }\n      \n      // 保存到本地存储\n      storage.set('taskHistory', taskHistory.value)\n    }\n  }\n\n  /**\n   * 从历史记录中移除\n   */\n  const removeFromHistory = (taskId) => {\n    taskHistory.value = taskHistory.value.filter(item => item.taskId !== taskId)\n    \n    // 保存到本地存储\n    storage.set('taskHistory', taskHistory.value)\n  }\n\n  /**\n   * 保存任务到本地存储\n   */\n  const saveTaskToStorage = async (task) => {\n    try {\n      storage.set(`task_${task.taskId}`, task)\n    } catch (error) {\n      console.error('保存任务到本地存储失败:', error)\n    }\n  }\n\n  /**\n   * 从本地存储移除任务\n   */\n  const removeTaskFromStorage = async (taskId) => {\n    try {\n      storage.remove(`task_${taskId}`)\n    } catch (error) {\n      console.error('从本地存储移除任务失败:', error)\n    }\n  }\n\n  /**\n   * 从本地存储恢复任务\n   */\n  const restoreTaskFromStorage = async (taskId) => {\n    try {\n      const task = storage.get(`task_${taskId}`)\n      if (task) {\n        currentTask.value = task\n        return task\n      }\n      return null\n    } catch (error) {\n      console.error('从本地存储恢复任务失败:', error)\n      return null\n    }\n  }\n\n  // 初始化\n  const initialize = async () => {\n    try {\n      // 加载历史记录\n      await loadTaskHistory()\n    } catch (error) {\n      console.error('初始化任务存储失败:', error)\n    }\n  }\n\n  // 返回状态和方法\n  return {\n    // 状态\n    currentTask,\n    taskHistory,\n    isLoading,\n    isDownloading,\n    transcriptionData,\n    \n    // 计算属性\n    currentProgress,\n    isProcessing,\n    isCompleted,\n    isFailed,\n    isTranscribing,\n    isTranscriptionCompleted,\n    isTranscriptionFailed,\n    \n    // 方法\n    createTask,\n    createUploadTask,\n    refreshTaskStatus,\n    updateTaskStatus,\n    updateCurrentTask,\n    startPolling,\n    stopPolling,\n    downloadVideo,\n    transcribeVideo,\n    getTranscriptionResult,\n    optimizeText,\n    cancelTask,\n    deleteTask,\n    retryTask,\n    loadTaskHistory,\n    clearHistory,\n    restoreTaskFromStorage,\n    initialize,\n    cleanupCurrentTask,\n    resetCurrentTask\n  }\n}) ","/**\n * 剪贴板工具函数\n */\n\n/**\n * 复制文本到剪贴板\n * @param {string} text - 要复制的文本\n * @returns {Promise<boolean>} - 复制是否成功\n */\nexport async function copyToClipboard(text) {\n  try {\n    // 优先使用现代 Clipboard API\n    if (navigator.clipboard && window.isSecureContext) {\n      await navigator.clipboard.writeText(text)\n      return true\n    }\n    \n    // 降级到传统方法\n    const textArea = document.createElement('textarea')\n    textArea.value = text\n    textArea.style.position = 'fixed'\n    textArea.style.opacity = '0'\n    textArea.style.left = '-999999px'\n    textArea.style.top = '-999999px'\n    \n    document.body.appendChild(textArea)\n    textArea.focus()\n    textArea.select()\n    \n    const success = document.execCommand('copy')\n    document.body.removeChild(textArea)\n    \n    return success\n  } catch (error) {\n    console.error('复制到剪贴板失败:', error)\n    return false\n  }\n}\n\n/**\n * 从剪贴板读取文本\n * @returns {Promise<string>} - 剪贴板中的文本\n */\nexport async function readFromClipboard() {\n  try {\n    // 只有在安全上下文中才能使用 Clipboard API\n    if (navigator.clipboard && window.isSecureContext) {\n      const text = await navigator.clipboard.readText()\n      return text\n    }\n    \n    // 无法在非安全上下文中读取剪贴板\n    throw new Error('无法读取剪贴板：需要安全上下文')\n  } catch (error) {\n    console.error('读取剪贴板失败:', error)\n    return ''\n  }\n}\n\n/**\n * 检查是否支持剪贴板操作\n * @returns {boolean} - 是否支持剪贴板操作\n */\nexport function isClipboardSupported() {\n  return !!(navigator.clipboard && window.isSecureContext)\n}\n\n/**\n * 检查文本是否可能是视频链接\n * @param {string} text - 要检查的文本\n * @returns {boolean} - 是否可能是视频链接\n */\nexport function isPossibleVideoLink(text) {\n  if (!text || typeof text !== 'string') {\n    return false\n  }\n  \n  // 常见视频平台域名\n  const videoPatterns = [\n    /douyin\\.com/i,\n    /dy\\.com/i,\n    /bilibili\\.com/i,\n    /b23\\.tv/i,\n    /youtube\\.com/i,\n    /youtu\\.be/i,\n    /kuaishou\\.com/i,\n    /ixigua\\.com/i,\n    /weibo\\.com/i,\n    /xiaohongshu\\.com/i\n  ]\n  \n  // 检查是否包含视频平台域名\n  return videoPatterns.some(pattern => pattern.test(text))\n}\n\n/**\n * 提取文本中的链接\n * @param {string} text - 要提取链接的文本\n * @returns {string[]} - 提取到的链接数组\n */\nexport function extractLinks(text) {\n  if (!text || typeof text !== 'string') {\n    return []\n  }\n  \n  // URL正则表达式\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/gi\n  const matches = text.match(urlRegex)\n  \n  return matches || []\n}\n\n/**\n * 清理和标准化文本\n * @param {string} text - 要清理的文本\n * @returns {string} - 清理后的文本\n */\nexport function cleanText(text) {\n  if (!text || typeof text !== 'string') {\n    return ''\n  }\n  \n  return text\n    .trim()\n    .replace(/\\s+/g, ' ') // 合并多个空格\n    .replace(/[\\r\\n]+/g, ' ') // 换行符转空格\n} "],"names":["isDevelopment","API_BASE_URL","api","axios","config","showLoadingToast","_a","error","closeToast","response","data","errorMessage","showToast","status","videoApi","url","platform","file","onProgress","MAX_SIZE","supportedTypes","supportedExtensions","fileExtension","formData","progressEvent","progress","taskId","params","hours","text","options","trimmedText","MAX_LENGTH","timeout","CHUNK_SIZE","chunks","sentences","currentChunk","i","sentence","optimizedChunks","errors","resolve","optimizedText","VideoCleaner","shouldClean","cleanUrl","videoCleaner","storage","key","defaultValue","item","value","total","useTaskStore","defineStore","currentTask","ref","taskHistory","isLoading","isDownloading","pollingTimer","transcriptionData","currentProgress","computed","isProcessing","isCompleted","isFailed","isTranscribing","isTranscriptionCompleted","isTranscriptionFailed","createTask","cleanupCurrentTask","saveTaskToStorage","addToHistory","startPolling","createUploadTask","taskForStorage","refreshTaskStatus","taskData","updateHistoryItem","updateTaskStatus","updateCurrentTask","updates","stopPolling","downloadVideo","downloadUrl","link","transcribeVideo","getTranscriptionResult","optimizeText","originalText","cancelTask","removeFromHistory","removeTaskFromStorage","deleteTask","retryTask","resetCurrentTask","loadTaskHistory","history","clearHistory","task","existingIndex","index","copyToClipboard","textArea","success","readFromClipboard"],"mappings":"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"}